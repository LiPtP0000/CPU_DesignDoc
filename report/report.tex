%!TEX program = xelatex
% 完整编译: xelatex -> biber/bibtex -> xelatex -> xelatex
\documentclass[lang=cn,a4paper,newtx]{elegantpaper}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\usepackage{subfig}
\usepackage{longtable}
\usepackage{lipsum}
\usepackage{makecell}
\usepackage{siunitx}
\usepackage{tikz-timing}
\usepackage{tikz}
\usepackage[table]{xcolor}
\usetikzlibrary{trees}
% \usepackage[backend=biber,style = gb7714-2015]{biblatex}
\addbibresource{reference.bib} % 参考文献，不要删除
\renewcommand{\listfigurename}{插图目录}
\renewcommand{\listtablename}{表格目录}
\renewcommand{\appendixname}{附录~\Alph{section}}
\renewcommand{\lstlistlistingname}{} % 去掉标题
\lstdefinelanguage{Assembly}{
  morekeywords={ ADD, SUB, MPY, JGZ, JMP, AND, OR,BUT,LOAD,STORE,SHIFTL,SHIFTR,HALT},  % 你可以在这里添加更多汇编指令
  sensitive=true,  % 保证区分大小写
  morecomment=[l]; % 单行注释（以分号开始）
  morestring=[b]",  % 字符串用双引号括起来
}
% Define the style for listings
\lstset{
  language=Verilog,  % 选择使用的语言
  basicstyle=\ttfamily\small,  % 基础字体风格
  keywordstyle=\color{blue}\bfseries,  % 指令的颜色和加粗
  commentstyle=\color{gray},  % 注释的颜色
  stringstyle=\color{red},  % 字符串的颜色
  identifierstyle=\color{purple},  % 标识符的颜色
  backgroundcolor=\color{lightgray!10}, % 背景色
  numbers=left,  % 行号显示在左侧
  stepnumber=1,  % 每行显示一个行号
  numberstyle=\tiny\color{gray},  % 行号的字体样式
  numbersep=5pt,  % 行号与代码之间的间距
  breaklines=true,  % 自动换行
  showstringspaces=false,  % 不显示字符串中的空格
  columns=flexible,  % 调整列宽
  frame=single,  % 在代码块外部加一个框
  framerule=0.5mm,  % 框线宽度
  rulesepcolor=\color{black},  % 分隔线颜色
  captionpos=b,  % 标题位置（b: bottom）
  }


  \tikzset{
  timing/name/.cd,
  I/.style={fill=blue!20},    % IF阶段
  D/.style={fill=green!20},   % ID阶段
  F/.style={fill=red!20},     % FO阶段
  N/.style={fill=yellow!20},  % IND阶段
  E/.style={fill=orange!20},  % EX阶段
  W/.style={fill=purple!20}   % WB阶段
}
% \renewcommand{\refname}{参考文献}
\title{计算机组织与结构II：CPU设计文档}
\author{
  李勃璘\thanks{东南大学吴健雄学院，学号：61522529} \and
  冯光宇\thanks{东南大学吴健雄学院，学号：61522527} \and
  张凯超\thanks{东南大学吴健雄学院，学号：61522522}
}

% \institute{吴健雄学院}

\version{1.0}
\date{\zhdate{2025/5/8}}

% 本文档命令
\usepackage{array}
\newcommand{\ccr}[1]{\makecell{{\color{#1}\rule{1cm}{1cm}}}}



\begin{document}

\maketitle
\thispagestyle{empty}
\begin{abstract}
  本文设计并实现了一个基于FPGA的16位单周期CPU，包括指令集架构、用户输入输出设计和完整的硬件实现。设计采用改进型冯·诺依曼结构，将指令内存和数据内存分离，使用统一的外部总线进行交互。CPU支持13条指令，包括数据传输、算术逻辑运算、移位及跳转指令，并实现了直接寻址和立即数寻址方式。为支持用户交互，设计了基于UART的指令输入接口以及LED与七段显示器的输出接口。本文详细介绍了CPU的整体架构、内部模块设计和实现方法，并对算术、逻辑、跳转运算和溢出处理功能进行了仿真和实物验证。实验结果表明，所设计的CPU能够正确执行各类指令并完成复杂计算任务，验证了设计的有效性和可靠性。
\end{abstract}

% Removed
% \vspace{1cm}

% \textbf{版本更新记录：}

% \begin{longtable*}{|c|c|p{10cm}|}
%   \hline
%   \textbf{版本号} & \textbf{日期} & \textbf{更新内容} \\
%   \hline
%   \endfirsthead

%   \hline
%   \textbf{版本号} & \textbf{日期} & \textbf{更新内容} \\
%   \hline
%   \endhead

%   v1.0 & 2025-03-22 & 初始版本，包含基本 CPU 设计框架，流水线结构，Verilog 实现。 \\
%   \hline
%   v1.1 & 2025-03-29 & 修改 \\

% \end{longtable*}


\newpage
\pagenumbering{roman}
\tableofcontents
\newpage
\listoffigures
\newpage
\listoftables
\newpage
\pagenumbering{arabic}
\lstset{nolol}
\section{概述}
\subsection{中央处理单元CPU简介}
中央处理单元（CPU）是计算机系统的核心组件，负责执行程序中的指令并处理数据。它由多个核心部件组成，包括算术逻辑单元（ALU）、控制单元（CU）、寄存器、缓存、总线以及与外部存储和外设的接口。CPU的设计和实现是计算机体系结构的基础，决定了计算机的性能、效率以及可扩展性。随着现代计算机技术的不断发展，CPU的设计已经经历了从单核到多核、从简单指令集到复杂指令集的转变，涉及到流水线、缓存管理、指令调度等多个高级设计问题。

在现代CPU中，指令集架构（ISA）定义了CPU能够识别并执行的指令类型，而ALU则负责执行这些指令中的算术和逻辑运算。控制单元（CU）则根据指令的操作码生成控制信号，协调CPU内部和外部的各个组件进行协作。此外，寄存器和缓存等存储单元在数据处理和存储中起着至关重要的作用。通过高效的设计和优化，CPU能够实现高速的计算和响应能力，从而支持各种计算任务的执行。

\subsection{NEXYS 4 DDR FPGA简介}

NEXYS 4 DDR 是一款基于 Xilinx Artix-7 FPGA 的高性能开发板，为数字电路设计提供了完整的开发平台。该开发板采用 Xilinx XC7A100T-1CSG324C FPGA，拥有丰富的片上资源：15,850 个逻辑片（每片含四个 6 输入查找表和 8 个触发器）、4,860 Kb 的块 RAM、240 个 DSP 片以及内置的 ADC 等模块。系统主频最高可达 450MHz，满足各类设计的高速运算需求\cite{nexys4ddr}。

在存储资源方面，NEXYS 4 DDR 配备了 128MiB 的 DDR2 SDRAM（16 位数据宽度）以及 16MB 的 Quad-SPI Flash 存储器，适合实现需要大量数据存储的应用。开发板支持通过 USB-JTAG 编程端口进行配置，也可以通过 Quad-SPI Flash 实现掉电后的程序保存。

在外部接口方面，NEXYS 4 DDR 提供了丰富的用户交互设备：
\begin{itemize}
  \item 16 个用户可编程的 LED 灯
  \item 两个 4 位 7 段数码管显示器
  \item 5 个按钮开关和 16 个滑动开关
  \item 3 轴加速度计
  \item 温度传感器
  \item 12 位 1MSPS 模数转换器
  \item PWM 音频输出接口
\end{itemize}

通信接口包括：
\begin{itemize}
  \item 10/100 以太网 PHY
  \item USB-UART 和 USB-HID 接口
  \item 支持 SD 卡的 Micro SD 插槽
  \item 多个 Pmod 接口，可扩展各类外设
  \item VGA 接口，支持 8 位颜色输出（512 种颜色）
  \item USB 主机接口，支持鼠标和键盘
\end{itemize}


此外，NEXYS 4 DDR 还配备了系统时钟发生器，提供 100MHz 的默认系统时钟。在电源管理方面，开发板具有自动监测和管理功能，能够通过 USB 或外部电源供电，并提供多种电压的稳压输出，确保系统稳定运行。

\subsection{本文内容安排}
本文通过设计一个基于NEXYS 4 DDR FPGA的简化CPU架构，探索了CPU的基本组成与工作原理。整个项目的设计过程中，从指令集的定义到硬件实现，涵盖了计算机体系结构中的核心概念与技术，旨在帮助深入理解CPU设计的各个方面。


本文接下来的章节安排如下：

第二章将介绍CPU内部架构，即指令集、内部寄存器、ALU、内外总线以及控制单元设计，第三章将主要介绍CPU外部设备的设计，包括前端输入指令、指令传入内存、内存格式和结果显示功能，第四章是二、三章提出的设计架构的Verilog HDL实现，第五章是该设计的资源分析、时序分析、整体仿真结果和在NEXYS 4 DDR FPGA开发板上的测试结果。第六章对该设计进行了总结，并提出一些可改进的方向。另外，附录中还提供了设计的全部Verilog代码和项目地址。

\section{CPU结构设计}
\subsection{总体架构}

% Need Update
CPU的总架构（包括内存、外设等）示意图可见图~\ref{fig:CPU}。
\begin{figure}[htbp]
  \centering
  \caption{CPU总体架构}
  \includegraphics[width = 0.95\textwidth]{figure/CPU_structure.pdf}
  \label{fig:CPU}
\end{figure}

CPU由控制单元（CU），内部寄存器（Registers）算术逻辑单元（ALU），内外控制总线（Internal/External Bus）、数据内存（Data RAM）和指令内存（Instruction ROM）组成，内部寄存器数据通路（Data Path）连接，同时被CU输出控制信号所驱动的控制通路（Control Path）所控制。另外，MAR和MBR分别还和外部地址总线、数据总线相连接，用于与内存交互。另外，CPU还通过UART接口接收用户输入的指令，并在用户发出请求时向LED和七段数码管输出图中标注绿色的寄存器的值。



\subsection{指令集架构}
指令集是指CPU能够对数据进行的所有操作的集合。每一条指令都可以被解释为寄存器与寄存器、内存、I/O端口之间的交互。交互方式由CU中的微指令（Micro-operation）给出，且每一条微指令都需要一个时钟执行（如不进行优化）。
\subsubsection{位宽设计}
地址段长为\textbf{8}位，指令码（Opcode）宽度为\textbf{8}位。因此，每一条指令的位宽为\textbf{16}位。


\subsubsection{指令集支持的指令}
指令集共支持13条不同的指令，列于表~\ref{tab:ISA:instructions}。每一条指令包含一个指令码，使用二进制格式存储。
  


\begin{longtable}{c c c}
  \caption{指令集包含指令及功能} \label{tab:ISA:instructions} \\
  \toprule
  助记符  & 指令码（低四位） & 描述 \\
  \midrule
  \endfirsthead
  
  \caption[]{（续表）指令集包含指令及功能} \\
  \toprule
  助记符  & 指令码（低四位） & 描述 \\
  \midrule
  \endhead
  
  \midrule
  \multicolumn{3}{r}{续下页} \\
  \midrule
  \endfoot
  
  \bottomrule
  \endlastfoot
  
  STORE X &  0001   & 结果存入\textbf{数据地址}X \\
  LOAD X  & 0010    & 加载\textbf{数据（数据地址）}X \\
  ADD X   & 0011    & 定点数加法\\
  SUB X   & 0100  & 定点数减法\\
  JGZ X   & 0101    & 结果 > 0时跳转至\textbf{指令地址}X\\
  JMP X   & 0110    & 无条件跳转至\textbf{指令地址}X\\
  HALT    & 0111    & 暂停程序\\
  MPY X   & 1000    & 定点数乘法 \\
  AND X   & 1001    & 按位与\\
  OR X    & 1010    & 按位或\\
  NOT X   & 1011    & 按位非 \\
  SHIFTR X & 1100    & 算术右移 X 位\\
  SHIFTL X & 1101    & 算术左移 X 位\\
\end{longtable}

\subsubsection{寻址方式}
寻址方式指对地址段数据的解释方式。寻址方式由对应指令指定，支持表~\ref{tab:ISA:addressingmode}~中的全部寻址方式。目前设计中指令码的最高位为1时，寻址方式为立即数寻址；指令码的最高位为0时，寻址方式为直接寻址。


\begin{longtable}{c c c}
  \caption{指令集支持的寻址方式} \label{tab:ISA:addressingmode} \\
  \toprule
  寻址方式  & 描述 & 最高位\\
  \midrule
  \endfirsthead
  
  \caption[]{（续表）指令集支持的寻址方式} \\
  \toprule
  寻址方式  & 描述 & 最高位\\
  \midrule
  \endhead
  
  \midrule
  \multicolumn{3}{r}{续下页} \\
  \midrule
  \endfoot
  
  \bottomrule
  \endlastfoot
  
  立即数寻址   &  地址字段是操作数本身，数据为补码格式  & 1\\
  直接寻址 &  地址字段为存放操作数的地址    & 0\\
\end{longtable}

在实际编程中，默认所有指令为\textbf{直接寻址}，除非指令中通过标注“IMMEDIATE”明确指定为立即数寻址\footnote{STORE、JGZ、JMP指令IMMEDIATE关键字无效，仅支持直接寻址。}。详细说明见第~\ref{sec:UserCode}~节。
\subsection{CPU内部寄存器}
该部分描述CPU内部寄存器的含义、存储格式和数据被解释为的格式。这些寄存器通过CPU的内部数据通路相连接。寄存器操作是CPU快速操作的核心。

\begin{longtable}{c c c c c c}
  \caption{CPU内部寄存器的含义、总存储条数、单位位宽和数据解释格式} \label{tab:CPU:datawidth} \\
  \toprule
  寄存器 & 含义 & 条数 & 位宽 & 数据解释格式 & 归属模块\\
  \midrule
  \endfirsthead

  \caption[]{（续表）CPU内部寄存器的含义、总存储条数、单位位宽和数据解释格式} \\
  \toprule
  寄存器 & 含义 & 条数 & 位宽 & 数据解释格式 & 归属模块\\
  \midrule
  \endhead

  \midrule
  \multicolumn{6}{r}{续下页} \\
  \midrule
  \endfoot

  \bottomrule
  \endlastfoot

  PC   & 程序计数器，存储当前指令地址             & 1  & 8   & 指令码（Opcode） & /\\
  MAR  & 内存地址寄存器，存储要访问的内存地址     & 1  & 8   & 地址码（Address）& /\\
  MBR  & 内存缓冲寄存器，存储从内存读取或写入的数据 & 1  & 16  & 二进制补码 & /\\
  IR   & 指令寄存器，存储当前正在执行的指令       & 1  & 8   & 指令码（Opcode）& /\\
  BR   & ALU内部寄存器，存储 ALU 计算结果        & 1  & 16  & 二进制补码 & ALU\\
  ACC  & 累加寄存器，存储 ALU 运算结果           & 1  & 16  & 二进制补码 & /\\
  MR   & ALU内部寄存器，存储 ALU 乘法高 16 位       & 1  & 16  & 二进制补码 & ALU\\
  CM   & 控制存储器，存储微指令控制信号         & 37 & 24  & 控制信号 & CU\\
  CAR  & 控制地址寄存器，指向当前执行的微指令   & 1  & 7   & CM中的条数下标 & CU\\
  CBR  & 控制缓冲寄存器，存储当前微指令的控制信号 & 1  & 24  & 控制信号 & CU\\
\end{longtable}

除上述寄存器以外，ALU进行运算时还会更改\textbf{状态寄存器}（Flags），用于CU进行条件判断。例如，JGZ命令需要判断上一步的运算结果是否大于0，CU便可以直接通过状态寄存器中的ZF（Zero Flag）和NF（Negative Flag）寄存器进行判断。本设计中使用的所有状态寄存器见表~\ref{tab:CPU:status}，它们都直接连向CU，通路不受控制信号的控制。Flags对用户公开，配置详见用户交互部分（第~\ref{sec:interaction}~节）。

\begin{longtable}{c c c}
  \caption{状态寄存器列表} \label{tab:CPU:status} \\
  \toprule
  寄存器 & 全称 & 行为 \\ 
  \midrule
  \endfirsthead

  \caption[]{（续表）状态寄存器列表} \\
  \toprule
  寄存器 & 全称 & 行为\\
  \midrule
  \endhead

  \midrule
  \multicolumn{3}{r}{续下页} \\
  \midrule
  \endfoot

  \bottomrule
  \endlastfoot

  ZF   & Zero Flag             & ALU运算结果为0时置1\\
  CF  & Carry Flag     & 存储算术移位移出的比特 \\
  OF  & Overflow Flag &  16位运算下BR溢出时置1，32位运算下MR溢出置1\\
  NF  & Negative Flag &  ALU运算结果为负数时置1\\
  MF & Multiply Flag & 运算结果超过16位，且高位未被读取时置1\\
\end{longtable}
\subsection{算术逻辑单元ALU}
算术逻辑单元ALU负责进行大部分CPU内的计算\footnote{自增与PC赋值在设计中不引入ALU。}。为简单起见，CPU的计算全部为\textbf{定点有符号数计算}。

ALU与外围寄存器的控制通路见第~\ref{sec:datapath}~节。ALU受到来自控制单元的$\text{ALU}_{en}$和$\text{ALU}_{op}$控制，前者决定ALU能否进行运算，后者决定ALU执行什么运算。在$\text{ALU}_{en}$为1时，它通过ACC和MBR获取运算的两个数据ALU\_P和ALU\_Q，并将计算结果存入16位BR寄存器（若出现过乘法且结果大于16位，则可能存入MR寄存器），同时根据ALU\_P、ALU\_Q和运算结果更新Flags寄存器。



表~\ref{tab:aluop}~描述了$\text{ALU}_{op}$与执行运算的对应关系。
\begin{longtable}{c c @{\hskip 2cm} c c}
  \caption{$\text{ALU}_{op}$ 与执行运算的对应关系} \label{tab:aluop} \\
  \toprule
  $\text{ALU}_{op}$ & 运算类型 & $\text{ALU}_{op}$ & 运算类型 \\
  \midrule
  \endfirsthead

  \caption[]{（续表）$\text{ALU}_{op}$ 与执行运算的对应关系} \\
  \toprule
  $\text{ALU}_{op}$ & 运算类型 & $\text{ALU}_{op}$ & 运算类型 \\
  \midrule
  \endhead

  \midrule
  \multicolumn{4}{r}{续下页} \\
  \midrule
  \endfoot

  \bottomrule
  \endlastfoot

  000 & 加法（ADD）       & 100 & 或（OR）         \\
  001 & 减法（SUB）       & 101 & 非（NOT）        \\
  010 & 乘法（MPY）       & 110 & 算术右移（SHIFTR）   \\
  011 & 与（AND）         & 111 & 算术左移（SHIFTL）   \\

\end{longtable}

由于在实际运算中，很可能会出现类似$m\times x +n$的运算。如果加法和减法不支持32位运算，则很可能导致乘法的结果也受溢出影响。因此，设计中引入了MF（Multiply Flag）寄存器，表示乘法运算的结果是否超过16位且未被存储。在MF为1时，加减法被允许进行32位运算，且在16位溢出时不会更新溢出标志位OF，而是从MR借位。而当出现存储指令STORE时，系统检测到此时MR和BR寄存器都不为0，则会顺次存储BR和MR寄存器（即执行STOREH指令，该指令是一条内部隐藏指令，具体内容见第~\ref{sec:ControlMemory}~节）。由于MR寄存器被读取，MF会被清零，以避免后续的加减法运算受到影响。

\subsection{控制单元CU}
控制单元（Control Unit, CU）负责协调和控制寄存器、ALU、内存等各个模块以实现指令的执行。它采用\textbf{微操作指令模式}设计，根据当前指令的操作码和状态寄存器的标志位生成相应的控制信号，指引数据通路中的各个寄存器、ALU、内存和外设进行正确的操作。\ref{sec:cu:structure}~节将介绍该控制单元的结构；\ref{sec:cu:micro}~节将具体描述本设计使用的微操作指令，并提供指令集的微操作指令表以供参考；\ref{sec:datapath}~节将介绍各个控制信号位的作用以及微操作指令表与控制信号的对应。

\subsubsection{控制单元结构}\label{sec:cu:structure}
控制单元由控制地址寄存器（Control Address Register, CAR）、控制数据寄存器（Control Buffer Register, CBR）和控制单元内存（Control Memory, CM）组成，并受到寻址逻辑（Sequencing Logic）的控制。在一个微操作指令周期，控制单元通过完成以下操作执行一个微操作：
\begin{enumerate}
  \item 根据CAR的地址，寻找CM对应地址存储的控制信号，并传输给CBR；
  \item CBR将控制信号译码，传输到相应的接收单元，并将下一跳信息传输给CAR；
  \item 寻址逻辑通过下一跳信息、Flags和Opcode确定下一跳地址，并写入CAR。
\end{enumerate}
控制单元示意图（图~\ref{fig:controlunit}）体现了CU内部的关键单元，以及上述操作的数据流向。

\begin{figure}[htbp]
  \centering
  \includegraphics[width = 0.45\textwidth]{figure/CU.pdf}
  \caption{控制单元结构示意图}
  \label{fig:controlunit}
\end{figure}

\subsubsection{微操作指令（Micro-Operations）}\label{sec:cu:micro}
指令集中所有指令都需要多个时钟周期完成，因此需要将指令集的指令分解为多步\textbf{微操作指令}。每步微操作指令通常为寄存器操作。按照寄存器操作的类型，可以将每条指令的执行整合为以下六个步骤，并按步骤顺序执行。
\begin{itemize}
  \item \textbf{IF(Instruction Fetch):}从指令存储器中取出指令，同时确定下一条指令地址（PC指向下一条指令）；
  \item \textbf{ID(Instruction Decode):}翻译指令，同时让计算机得出要使用的运算，并得出寻址方式。
  \item \textbf{FO(Fetch Operands):}取立即操作数到MBR，即指令的低8位。
  \item \textbf{IND(Indirect):}间接寻址周期，每插入一个IND周期则间接寻址深度+1。不插入IND周期则为立即数寻址。在本设计中由于不考虑间接寻址，因此最多只有1个IND周期。\textbf{立即数寻址的指令将跳过这一阶段。}
  \item \textbf{EX(Execution):}按照微操作指令指示打开数据通路。
  \item \textbf{WB(Write Back):}将运算结果保存到目标寄存器。
\end{itemize}

注意到：对于所有的指令，前四个阶段的微操作指令是通用的，因此对每一条指令而言，只需要设计EX阶段和WB阶段的微操作指令即可，这大大缩小了CM所需空间。

另外，为了更好地支持用户面操作和32位算术运算，在微操作指令层面添加了两条非指令集中的指令：
\texttt{NOP}和\texttt{STOREH}。它们的作用分别是：
\begin{itemize}
  \item \texttt{NOP}：空指令，CPU在执行该指令时不进行任何操作。该指令的作用是缓冲，保证CPU在不需要执行指令时不进行取指，不更改寄存器，不读写内存。
  \item \texttt{STOREH}：存储高位指令，在MR为1时，若本次指令为STORE，则在存放ACC寄存器后，继续将MR寄存器的高位通过ACC寄存器存入地址+1位置的内存，并在读取MR时清空MR的值。该指令的作用是将乘法运算的高位低位结果都存储到内存中。
\end{itemize}

经设计，所有的微操作指令列举于表~\ref{tab:five_stage_pipeline}。

\begin{longtable}{cccc}
  \caption{CPU微操作指令表} \label{tab:five_stage_pipeline}\\
  \toprule
  指令 & 机器码  & EX & WB \\
  \midrule
  \endfirsthead

  \toprule
  \caption[]{（续表）CPU微操作指令表} \\
  \toprule
  指令 & 机器码 & EX & WB \\
  \midrule
  \endhead

  \bottomrule
  \endlastfoot
  \rowcolor{red!10}
  IF & \textbf{阶段} & \multicolumn{2}{c}{$t_1$:MAR ← PC; $t_2$: MBR ← Mem[MAR], PC ← PC+1} \\
  \midrule
  \rowcolor{yellow!10}
  ID & \textbf{阶段} & \multicolumn{2}{c}{$t_1$:IR ← MBR; $t_2$: CU ← IR[15:8]}\\
  \midrule
  \rowcolor{blue!10}
  FO & \textbf{阶段} & \multicolumn{2}{c}{MBR ← IR[7:0]} \\
  \midrule
  \rowcolor{green!10}
  
  IND & \textbf{阶段} & \multicolumn{2}{c}{$t_1$:MAR ← MBR;  $t_2$:MBR ← Mem[MAR]}\\
  \midrule
  NOP & / & 无操作 & 无操作 \\
  \midrule
  STORE X & 0001  & \makecell{MAR ← MBR;\\ MBR ← ACC} & Mem[MAR] ← MBR \\
  STOREH X      & 0001 + MF = 1 & \makecell{MAR ← MBR;\\ MBR ← ACC} &  \makecell{Mem[MAR] ← MBR;\\ ACC ← MR, MAR + 1}  \\
                & \textbf{存储高位} & MBR ← MR & Mem[MAR] ← MBR; \\
  \midrule
  LOAD X & 0010 &
  无操作 & 
  ACC ← MBR \\
  \midrule
  ADD X & 0011 &
  
  BR ← ACC + MBR & 
  ACC ← BR \\

  SUB X & 0100 &
  
  BR ← ACC - MBR & 
  ACC ← BR \\
  MPY X & 1000 &
  
  MR, BR ← ACC × MBR &
  ACC ← BR \\
  \midrule
  JGZ X & 0101 &
   
  判断：ZF=0 且 NF=0？ & 
  \makecell{若满足，PC ← MBR，\\否则 NOP）} \\

  JMP X & 0110 &
  
  无操作 & 
  PC ← MBR \\

  HALT & 0111 &
  
  无操作 & 
  停止程序 \\

  
  \midrule
  AND X & 1001 &
  
  BR ← ACC AND MBR &
  ACC ← BR \\

  OR X & 1010 &
  
  BR ← ACC OR MBR &
  ACC ← BR \\

  NOT X & 1011 &

  BR ← NOT MBR &
  ACC ← BR \\

  SHIFTR X & 1100 &
  
  BR ← ACC $\ggg $ X &
  ACC ← BR \\

  SHIFTL X & 1101 &
  
  BR ← ACC $\lll$ X &
  ACC ← BR \\

\end{longtable}
\subsubsection{CU控制信号（Control Signals）}\label{sec:datapath}
采用水平微指令（Horizontal Micro-operation）设计。水平微指令支持并行操作，执行效率高。每一个水平微指令携带\textbf{所有控制信号位}和\textbf{下一个微操作指令地址的寻址方式}。该CPU共有\textbf{24}位控制信号。其中低16位为寄存器控制信号，高8位为控制字。（图~\ref{fig:control_signal_diagram}）

\begin{figure}[htbp]
  \centering
  \caption{控制信号示意图}
  \label{fig:control_signal_diagram}
  \begin{tikzpicture}[node distance=1cm]
  
  % 第一行：控制信号位
  \node (C23) [draw, rectangle, minimum width=1cm, minimum height=1cm] {HLT};
  \node (C22) [draw, rectangle, minimum width=1cm, minimum height=1cm, right of=C23] {SHP};
  \node (C21_20) [draw, rectangle, minimum width=1.5cm, minimum height=1cm, right of=C22,xshift = 0.25cm] {ADDR};
  \node (C19)[draw, rectangle, minimum width=1.5cm, minimum height=1cm, right of=C21_20,xshift = 0.5cm] {$\text{ALU}_{en}$};
  \node (C19_16) [draw, rectangle, minimum width=2cm, minimum height=1cm, right of=C19, xshift=0.75cm] {$\text{ALU}_{op}$};
  \node (C15_0) [draw, rectangle, minimum width=6cm, minimum height=1cm, right of=C19_16, xshift=3cm] {REG Control};
  
  % 第二行：位描述
  % \node (above1) [above left of=C23, text width=2cm, align=center] {\small 23};
  \node (above2) [above left of=C22, text width=2cm, align=center] {\small 23};
  \node (above3) [above left of=C21_20, xshift = -0.1cm,text width=2cm, align=center] {\small 22};
  \node (above4) [above left of=C19, xshift = -0.2cm,text width=2cm, align=center] {\small 20};
  \node (above5) [above left of=C19_16, xshift = -0.4cm,text width=2cm, align=center] {\small 19};
  \node (above6) [above left of=C15_0, xshift = -2.4cm,text width=2cm, align=center] {\small 16};
  \node (above7) [above right of=C15_0, xshift = 2.2cm,text width=0.5cm, align=center] {\small 0};
  % 第三行：复用控制信号位
  \node (C2_desc) [below left of=C15_0, yshift=-0.2cm, text width=5cm, align=center] {\small $C_2$（复用）: 指令寄存器读、PC自增};
  
  \end{tikzpicture}
  
  
  \end{figure}

  各控制字的意义如下：
\begin{itemize}
  \item HLT(Halt)：全局停止控制字，所有CPU内部单元停止工作。
  \item SHP(Store High Part)：存储乘法寄存器高位结果到指定数据内存地址+1。
  \item ADDR(Address)：CU内部控制字，共2位，指示下一步的地址为取指（11）/执行（01）/当前地址+1（10）。
  \item $\text{ALU}_{en}$：ALU使能控制字，允许ALU进行运算操作。
  \item $\text{ALU}_{op}$：ALU运算控制字（3位），指示ALU执行的8种运算类型。运算类型编码可见ALU部分。
  \item REG\_Control：寄存器控制信号（16位），每一位代表两个寄存器/总线之间的开关，对应关系见表~\ref{tab:CPU:DataPath}。
  \item $C_2$：复用控制字。除寄存器控制信号的功能外，还指示指令寄存器读、PC自增。
\end{itemize}

关键存储单元之间通过数据通路进行连接。每条数据通路都由一位控制信号控制。控制信号为1时表示通路打开，数据沿指定流向进行传输。参考图~\ref{fig:CPU}~使用箭头标出的通路，分配控制信号位如表~\ref{tab:CPU:DataPath}~所示。
\begin{longtable}{c c c}
  \caption{寄存器控制信号一览} \label{tab:CPU:DataPath} \\
  \toprule
  控制信号位 & 源寄存器/单元  & 目的寄存器/单元   \\
  \midrule
  \endfirsthead

  \caption[]{（续表）数据通路与控制信号一览} \\
  \toprule
  控制信号位 & 源寄存器/单元  & 目的寄存器/单元  \\
  \midrule
  \endhead

  \midrule
  \multicolumn{3}{r}{续下页} \\
  \midrule
  \endfoot

  \bottomrule
  \endlastfoot

  $C_0 $ & MAR   & 地址总线  \\
  $C_1 $ & PC    & MBR  \\
  $C_2 $ & PC    & MAR  \\
  $C_3 $ & MBR   & PC  \\
  $C_4 $ & MBR   & IR  \\
  $C_5 $ & 数据总线 & MBR  \\
  $C_6 $ & MBR   & ALU\_Q \\
  $C_7 $ & ACC   & ALU\_P  \\
  $C_8 $ & MBR   & MAR  \\
  $C_9 $ & BR   & ACC  \\
  $C_{10}$ & MR   & ACC    \\
  $C_{11}$ & MBR   & ACC  \\
  $C_{12}$ & ACC   & MBR  \\
  $C_{13}$ & MBR   & 数据总线  \\
  $C_{14}$ & IR[15:0]    & CU  \\
  $C_{15}$ & IR[7:0]    & MBR \\
\end{longtable}

由上述的控制信号位设计，便可以将微操作指令一一对应，画出控制信号表（表~\ref{tab:five_stage_pipeline_ctrl}）。控制信号表经过整合后写入CM，结合CU的整体结构和合理的寻址设计，便能完成控制单元的设计。整合逻辑和寻址设计由于涉及到具体电路安排，详见模块设计部分，此处从略。
\begin{longtable}{cccc}
  \caption{CPU控制信号表} \label{tab:five_stage_pipeline_ctrl}\\
  \toprule
  指令 & 机器码  & EX & WB \\
  \midrule
  \endfirsthead

  \toprule
  \caption[]{（续表）CPU控制信号表} \\
  \toprule
  指令 & 机器码 & EX & WB \\
  \midrule
  \endhead

  \bottomrule
  \endlastfoot
  \rowcolor{red!10}
  IF & \textbf{阶段} & \multicolumn{2}{c}{$t_1:C_2$, $t_2:C_0$,$C_5$} \\
  \midrule
  \rowcolor{yellow!10}
  ID & \textbf{阶段} & \multicolumn{2}{c}{$t_1:C_4$,  $t_2:C_{14}$}\\
  \midrule
  \rowcolor{blue!10}
  FO & \textbf{阶段} & \multicolumn{2}{c}{$C_{15}$} \\
  \midrule
  \rowcolor{green!10}
  IND & \textbf{阶段} & \multicolumn{2}{c}{$t_1:C_8$, $t_2:C_0,C_5$}\\
  \midrule
  NOP & /  & 无操作 & 无操作 \\
  \midrule
  STORE X & 0001   & $C_8$,$C_{12}$ & $C_0$,$C_{13}$ \\

  STOREH X &  0001 + MF为1   & $C_{8}$,$C_{12}$ & $C_{0}$,$C_{10}$,$C_{13}$,SHP \\
          & \textbf{存储高位} & $C_{12}$ & $C_0$,$C_{13}$ \\

  \midrule

  LOAD X & 0010  & 
  无操作 & 
  $C_{11}$ \\
  \midrule
  ADD X & 0011 &
  
  $C_6$,$C_7$,$\text{ALU}_{en}$,$\text{ALU}_{op}$ & 
  $C_9$ \\

  SUB X & 0100 &
  $C_6$,$C_7$,$\text{ALU}_{en}$,$\text{ALU}_{op}$ & 
  $C_9$ \\
  MPY X & 1000 &
  $C_6$,$C_7$,$\text{ALU}_{en}$,$\text{ALU}_{op}$ &
  $C_9$ \\
  \midrule
  JGZ X & 0101 &
  
  判断：ZF=0 且 NF=0? & 
  \makecell{若满足，$C_3$\\否则 NOP} \\

  JMP X & 0110 &
  
  无操作 & 
  $C_3$ \\

  HALT & 0111 &
  
  无操作 & 
  HLT \\

  
  \midrule
  AND X & 1001 &
  
  $C_6$,$C_7$,$\text{ALU}_{en}$,$\text{ALU}_{op}$ &
  $C_9$ \\

  OR X & 1010 &
  
  $C_6$,$C_7$,$\text{ALU}_{en}$,$\text{ALU}_{op}$ &
  $C_9$ \\

  NOT X & 1011 &
  
  $C_6$,$\text{ALU}_{en}$,$\text{ALU}_{op}$ &
  $C_9$ \\

  SHIFTR X& 1100 &
  $C_6$,$C_7$,$\text{ALU}_{en}$,$\text{ALU}_{op}$ &
  $C_9$ \\

  SHIFTL X& 1101 &
  $C_6$,$C_7$,$\text{ALU}_{en}$,$\text{ALU}_{op}$ &
  $C_9$ \\

\end{longtable}

\subsection{CPU内部总线和外部总线}\label{sec:ExternalControl}
为了实现CU对CPU内部寄存器的控制，所有内部寄存器均连接到CPU内部总线。CU可对CPU内部总线写控制信号，而所有内部寄存器通过读取内部总线中的某一位或几位控制信号，决定打开自身与某寄存器的数据通路。在本设计中，控制寄存器的控制信号作用于\textbf{源寄存器}，使得在控制信号关时，数据通路上没有来自源寄存器的数据，避免了可能的误读。控制信号也作用于\textbf{目标寄存器}，防止“0”数据与“无输入”数据混淆。例如：对于PC寄存器，其向MAR、MBR输出自身数据，并从MBR获取数据，三个行为分别由$C_1$、$C_2$和$C_3$控制，那么PC需要监测这三个控制信号的状态，并在它们为高电平时输出或在下一个周期更新自身寄存器的值。

MAR和MBR寄存器是CPU与内存或外设的交互接口。由表~\ref{tab:CPU:DataPath}~可知：他们连向了\textbf{地址总线}和\textbf{数据总线}，这两根总线合称外部总线。地址总线为\textbf{8}位单向总线，提供CPU（即MAR）到内存的地址传送通路。数据总线为\textbf{16}位双向总线，提供CPU（即MBR）与内存的双向数据通路。

外部总线还负责管理内存的读写以及选择读写内存设备，受到控制信号$C_0$、$C_2$、$C_5$、$C_{13}$的控制，他们构成了外部总线的4位\textbf{控制总线}。由于指令和数据的物理存储空间不同，外部总线首先需要确定写入/读取的设备。在整个指令执行的流程中，仅IF阶段需要访问指令内存进行寻址，故该判决逻辑可通过复用控制信号的$C_2$完成。CPU读内存时，$C_0$、$C_5$开，故当且仅当两者同开时，总线可向选中的内存发出读信号，内存读地址总线，向数据总线输出相应地址的数据。CPU写内存时，$C_0$、$C_{13}$开，故当且仅当两者同开时，总线可向选中的内存发出写信号，内存读地址总线，读数据总线并存入对应地址。

\subsection{数据内存}
数据内存（RAM）存储CPU保存的数据。内存的大小为 512 Byte，每条存入内存的数据位宽为16，共能存入256条数据。数据内存初始为空，起始写入地址为0，采用Little Endian写入方式\footnote{即高位存储于高地址，低位存储于低地址。}。

CPU与数据内存通过三条外部总线交互，控制总线中的控制信号决定在这个周期中内存的读/写状态，是否向数据总线写入，同步时序等功能。内存通过读取地址总线决定写入内存中的地址，通过读取数据总线决定写入指定地址中的数据。关于总线的具体配置见~\ref{sec:ExternalControl}。

\subsection{指令内存}
传入FPGA的所有指令存于单独的指令内存（ROM）中，与CPU数据内存隔离开来，CPU内存仅存数据，这符合用户编写的直观感受，适合内存管理。指令内存的大小也为 512 Byte，每条存入内存的指令大小为2byte，共能存入256条指令。指令内存初始为空，起始写入地址为1。

CPU和指令内存也通过相同的三条外部总线交互，并由控制总线决定在这个周期中是否读指令内存。指令内存通过读取地址总线决定读取指令内存中的地址，通过读取数据总线决定读取指定地址中的数据。

在本设计中，指令内存的初始值通过板载UART/FIFO接口输入指令ROM，详见第~\ref{sec:UserCode}~节。

\section{用户交互设计}
\subsection{指令写入设计}
本设计采用\textbf{用户编写汇编代码}$\to$\textbf{python脚本转换为16位机器码}$\to$\textbf{UART/FIFO}的方式向指令内存输入指令。该方案无需额外的数据线或 I/O 资源，直接复用JTAG烧录线即可实现对指令内存的程序写入，提升了系统的硬件集成度与使用便捷性。

\subsubsection{用户端代码编译}\label{sec:UserCode}
用户可在文本编辑器中编写类汇编代码，而编译器负责将其编译为机器码。

以从1加到100的程序举例：
\begin{lstlisting}[language=Assembly]
  LOAD IMMEDIATE 0
  STORE 1
  LOAD IMMEDIATE 1
  STORE 2
  LOOP: LOAD 1
  ADD 2
  STORE 1
  LOAD 2
  ADD IMMEDIATE 1
  STORE 2
  LOAD IMMEDIATE 101
  SUB 2
  JGZ LOOP
  LOAD 1
  HALT                ; Expected 5050
\end{lstlisting}

代码最终将被解释为一串二进制比特流，解释服从：
\begin{itemize}
  \item 地址占1byte，Opcode占1byte；
  \item 含IMMEDIATE关键字的行，或STORE、JMP、JGZ指令的Opcode的MSB为1；
  \item 第一条指令的地址为1，依次递增;
  \item 在汇编代码编译的过程中，标签（\texttt{LOOP}）应映射到相同行指令的地址；
  \item 一行内分号后的内容为注释，编译器会忽略它。
\end{itemize}

按照上述规则，示例代码将被编译为如下机器码：
\begin{lstlisting}[language = Assembly]
8200      ; 8XXX = IMMEDIATE
8101
8201
8102
0201      ; LOOP Address: Line 05
0302
8101
0202
8301
8102
8265
0402
8505      ; Operand 05 = LOOP Address
0201
0700
\end{lstlisting}
\subsubsection{UART 接收逻辑}

开发板主系统时钟频率为 \SI{100}{\mega\hertz}，串口通信波特率设定为 \SI{115200}{bps}。根据 UART 通信协议，每接收 $1$ 位数据所需的时钟周期数为：

\begin{equation}
  \text{CLK\_BAUD} = \frac{\text{CLK\_FREQ}}{\text{BAUD\_RATE}} = \frac{100\,000\,000}{115200} \approx 868
\end{equation}

采用UART传输常见的 \textbf{8N1} 格式传输，即每帧包括：

\begin{itemize}
  \item 1 位起始位（Start Bit）；
  \item 8 位数据位（Data Bits）；
  \item 1 位停止位（Stop Bit）。
\end{itemize}

因此，每帧共 $10$ 位，总计需要约：

\begin{equation}
  \text{CLK\_FRAME} = 10 \times \text{CLK\_BAUD} = 10 \times 868 = 8680\ \text{cycles}
\end{equation}

接收端在每位中间进行采样，保证采样数据稳定，并认为超过0.5秒RX端仍无新数据填入时（保持高电平），指令传输完成。CPU会向用户发出提示，指示接收完成。

\subsubsection{FIFO数据缓冲与存储结构}

为保证串口数据完整接收，接收模块首先将每帧数据写入异步 FIFO 缓冲区。FIFO将两帧数据合并在一起，以完整指令格式由控制逻辑从 FIFO 中读取数据，并写入指令内存。

\paragraph{数据写入格式：}

\begin{itemize}
  \item 可确保 FIFO 中每帧数据均为 16 位数据，不会出现奇数字节的数据包；
  \item 指令内存地址从地址 1 开始顺序写入。
  \item 指令内存的每个地址对应两个字节（16 位）数据；
  \item 高字节为操作码（Opcode），低字节为立即数或地址（Operand）；
\end{itemize}



\subsection{板载交互设备配置}\label{sec:interaction}
用户可以通过FPGA板上的按钮和开关与CPU进行交互，并通过LED灯和七段数码管查看CPU的运行状态和计算结果。具体设计如下：
\paragraph{全局复位}

按下上侧按钮（BTNH）时，CPU触发全局复位信号，所有寄存器和内存数据清空，控制信号复位为初始状态。

\paragraph{运行与停止}

最右侧开关控制CPU的运行状态：
\begin{itemize}
  \item 开启状态：CPU开始执行指令。
  \item 关闭状态：CPU停止运行并保持当前状态。
\end{itemize}
当CPU发出停止信号（HALT）时，右侧LED灯亮红色；当CPU处于运行状态时，右侧LED灯亮蓝色。

\paragraph{运行模式与单步调试模式}

CPU支持两种模式：
\begin{itemize}
  \item \textbf{运行模式}：CPU自动连续执行指令直至停止，适合快速验证结果。
  \item \textbf{单步调试模式}：用户通过按下最中间的按钮（BTNC）控制CPU逐条执行指令。每次执行完一条指令后，CPU暂停，等待用户操作。
\end{itemize}

CPU运行开关左侧相邻开关控制模式选择：
\begin{itemize}
  \item 开启状态：单步调试模式，左侧LED灯亮红色。
  \item 关闭状态：运行模式，左侧LED灯亮蓝色。
\end{itemize}

\paragraph{结果与指令查看}

\begin{itemize}
  \item 按下左侧按钮（BTNL）：查看当前运算结果。
  \item 按下右侧按钮（BTNR）：查看当前指令码和指令地址。
  \item 按下下侧按钮（BTND）：查看当前Flags寄存器的值。
\end{itemize}
\section{核心模块设计}
\label{sec:core_module_design}
本设计除Testbench以外的Verilog模块按照图~\ref{fig:CPU:implementation}~所示的层次结构进行组织。本章接下来将按照用户与CPU交互→CPU内部数据流→CPU输出反馈的逻辑路径，也即层次结构图从下至上，从右至左的顺序进行介绍。
\begin{figure}[htbp]
   \centering
   \caption{CPU模块结构图}
   \label{fig:CPU:implementation}
   \begin{tikzpicture}[
     level 1/.style={level distance=3cm,sibling distance=1cm},
     level 2/.style={level distance =3cm,sibling distance=5cm},
     level 3/.style={sibling distance=1cm},
     every node/.style={draw=none, align=left}
   ]
     \node {TOP}[edge from parent fork right,grow=right]
       child [sibling distance = 3.5cm]{node {CPU\_TOP}
          child {node {INSTR\_ROM}
          child {node {UART}}
          child {node {FIFO}}
          child {node {BRAM\_INSTR}}
          }
         child {node {CU\_TOP}
           child {node {CAR}}
           child {node {CBR}}
           child {node {\makecell{CONTROL\_\\MEMORY}}}
         }
         child {node {REG\_TOP}
           child {node {PC}}
           child {node {IR}}
           child {node {ACC}}
           child {node {MAR}}
           child {node {MBR}}
           child {node {ALU}}
         }
         child [sibling distance = 3cm]{node {DATA\_RAM}}
         child  [sibling distance = 1cm]{node {EXTERNAL\_BUS}}
       }
      child {node {KEY\_JITTER}}
      child {node {LED\_DISPLAY}}
      child {node {\makecell{SEVEN\_SEG\\MENT\_DISPLAY}}
        child {node {\makecell{SEGMENT\_\\DISPLAY}}}
      };
       
   \end{tikzpicture}
  \end{figure}
  
\subsection{时钟、复位与停止信号}
CPU由\textbf{全局同步时钟}控制，时钟主频为100MHz。除异步复位信号外，所有分频时钟、控制逻辑与计算逻辑全部在该时钟上升沿进行。

CPU设有\textbf{全局异步复位}信号，低电平有效。当异步复位时，内存中除指令集数据以外所有数据清空，所有寄存器清空，控制信号全部归为断开（0）。

当CPU执行07号指令HALT时，CPU处于\textbf{停止}状态，发出HLT信号。与复位不同的是，此时所有寄存器不清空，但所有通路断开。解除该状态的唯一方法是全局复位。

\subsection{UART传输与指令内存}
指令写入通过Python脚本（附录~\ref{sec:appendices:python}~）完成，其可以根据用户编写的\texttt{txt}格式汇编代码（格式参照~\ref{sec:UserCode}~）输出一串UART格式的比特流。用户可在python程序中设置连接UART端口的USB端口，通过PySerial串口通信库进行传输，或复制脚本的输出作为输入测试样例。
\paragraph{模块代码：}
见附录~\ref{sec:appendices:uart}。
\paragraph{功能块基本信息：}
\begin{itemize}
  \item 模块名：\texttt{INSTR\_ROM}
  \item 最新更新日期：\texttt{5.6}
  \item 是否经过测试：是
\end{itemize}

\paragraph{功能块外部接口：}
\begin{longtable}{>{\bfseries}c c c c}
  \caption{指令内存模块外部接口} \\ 
  \toprule
  信号名 & 方向 & 位宽 & 描述 \\
  \midrule
  \endfirsthead

  \multicolumn{4}{l}{\textbf{（续表）指令内存模块外部接口}} \\
  \toprule
  信号名 & 方向 & 位宽 & 描述 \\
  \midrule
  \endhead
  
  \texttt{i\_clk\_uart} & 输入 & 1 & 时钟信号（100MHz） \\
  \texttt{i\_rst\_n} & 输入 & 1 & 全局复位信号 \\
  \texttt{i\_rx} & 输入 & 1 & 绑定至UART接收引脚 \\
  \texttt{i\_addr\_read} & 输入 & 8 & 读指令内存地址 \\
  \texttt{o\_instr\_read} & 输出 & 16 & 指令输出信号 \\
  \texttt{o\_instr\_transmit\_done} & 输出 & 1 & 指令完成传入标志 \\
  \texttt{o\_max\_addr} & 输出 & 8 & 最大地址输出 \\
  \bottomrule
\end{longtable}


\subsubsection{UART模块}
\paragraph{模块基本信息：}
\begin{itemize}
  \item 模块名：\texttt{UART}
  \item 最新更新日期：\texttt{5.6}
  \item 是否经过测试：是
\end{itemize}
\paragraph{模块功能：}
将用户输入代码比特流（8N1格式）译码为1字节数据。

\paragraph{模块外部接口：}

\begin{longtable}{>{\bfseries}c c c c}
  \caption{UART模块外部接口} \\
  \toprule
  信号名 & 方向 & 位宽 & 描述 \\
  \midrule
  \endfirsthead

  \multicolumn{4}{l}{\textbf{（续表）UART模块外部接口}} \\
  \toprule
  信号名 & 方向 & 位宽 & 描述 \\
  \midrule
  \endhead

  \texttt{i\_clk}   & 输入  & 1      & 分频后的时钟信号（分频时钟代码见\hyperref[sec:appendices:uart]{clk\_divider.v}） \\
  \texttt{i\_rst\_n} & 输入  & 1      & 全局复位信号 \\
  \texttt{i\_rx}    & 输入  & 1      & UART 接收引脚 \\
  \texttt{o\_data}  & 输出  & 8    & 接收到的一帧数据 \\
  \texttt{o\_valid} & 输出  & 1      & 数据有效标志，高电平表示 \texttt{o\_data} 已生成 \\
  \texttt{o\_clear\_sign}    & 输出   & 1       & 表示UART输入结束（第一次输入结束后0.5秒内无新的输入）\\
  \bottomrule
\end{longtable}

\paragraph{模块行为：}
\begin{itemize}
  \item 当\texttt{i\_rst\_n}为低电平时，模块复位，状态机进入\texttt{START}状态，清空接收寄存器和计数器；
  \item 在\texttt{START}状态下，若\texttt{i\_rx}信号检测到起始位（低电平），状态机在下一波特率时钟进入\texttt{DATA}状态，否则\texttt{rx\_no\_data\_counter}计数器在每个波特率时钟计数；
  \item 在\texttt{DATA}状态下，在波特率时钟\textbf{下降沿}采样数据，依次存入移位寄存器，使得其可在信号位中点采样数据，增加稳定性；
  \item 在接收完8位数据后，状态机进入\texttt{STOP}状态，检测停止位（高电平）；
  \item 若停止位有效，输出接收到的8位数据到\texttt{o\_data}，并将\texttt{o\_valid}置高，表示数据有效；状态机在完成当前帧的接收后返回\texttt{START}状态，等待下一帧数据。
  \item 若在\texttt{START}状态下超过0.5秒未接收到新数据，即\texttt{rx\_no\_data\_counter}计数至434，\texttt{o\_clear\_sign}置高，表示UART输入结束；
\end{itemize}
\subsubsection{FIFO模块}
\paragraph{模块基本信息：}
\begin{itemize}
  \item 模块名：\texttt{FIFO}
  \item 最新更新日期：\texttt{4.13}
  \item 是否经过测试：是
\end{itemize}
\paragraph{模块功能：}
异步FIFO，缓存UART数据并处理UART模块和CPU主模块的跨时钟域问题。它将每两个读出的UART数据拼成2字节的指令输出给指令内存。
\paragraph{模块外部接口：}
\begin{longtable}{>{\bfseries}c c c c}
  \caption{FIFO模块外部接口} \\
  \toprule
  信号名 & 方向 & 位宽 & 描述 \\
  \midrule
  \endfirsthead

  \multicolumn{4}{l}{\textbf{（续表）FIFO模块外部接口}} \\
  \toprule
  信号名 & 方向 & 位宽 & 描述 \\
  \midrule
  \endhead

  \texttt{i\_rst\_n}         & 输入  & 1        & 异步复位信号，低有效 \\
  \texttt{i\_clk\_wr}        & 输入  & 1        & 写时钟信号，UART 使用的 波特率 时钟 \\
  \texttt{i\_valid\_uart}    & 输入  & 1        & 表示当前 UART 输入数据有效 \\
  \texttt{i\_data\_uart}     & 输入  & 8        & UART 接收到的 8 位数据字节 \\
  \texttt{i\_clk\_rd}        & 输入  & 1        & 读时钟信号，使用100MHz 时钟 \\
  \texttt{o\_data\_bram}     & 输出  & 16       & 两个 UART 字节拼接后的数据，写入 指令内存 \\
  \texttt{o\_addr\_bram}     & 输出  & 8        & 指令内存写入地址，从 0 开始自增 \\
  \texttt{o\_wr\_en\_bram}   & 输出  & 1        & 指令内存写使能，高电平表示写入有效 \\
  \texttt{o\_fifo\_empty}    & 输出   & 1       & 表示FIFO空（作为输入完成的判据）\\
  \bottomrule
\end{longtable}
\paragraph{模块行为：}
\begin{itemize}
  \item 当\texttt{i\_rst\_n}为低电平时，FIFO复位：
    \begin{itemize}
      \item 写指针\texttt{wr\_ptr\_bin}和读指针\texttt{rd\_ptr\_bin}清零；
      \item FIFO存储器\texttt{fifo\_mem}清空；
      \item 输出信号\texttt{o\_data\_bram}、\texttt{o\_addr\_bram}和\texttt{o\_wr\_en\_bram}复位为0。
    \end{itemize}
  \item 当\texttt{i\_valid\_uart}信号有效时：
    \begin{itemize}
      \item 若FIFO未满（\texttt{!fifo\_full}），将\texttt{i\_data\_uart}写入\texttt{fifo\_mem}中\texttt{wr\_ptr\_bin}指向的地址；
      \item 写指针\texttt{wr\_ptr\_bin}递增，并更新为Gray码\texttt{wr\_ptr\_gray}。
    \end{itemize}
  \item 在读时钟域（\texttt{i\_clk\_rd}）：
    \begin{itemize}
      \item 若FIFO非空（\texttt{!fifo\_empty}），从\texttt{fifo\_mem}中\texttt{rd\_ptr\_bin}指向的地址读取数据；
      \item 若当前为第一个字节（\texttt{byte\_flag}为0），将数据存入缓冲区\texttt{data\_buffer}；
      \item 若当前为第二个字节（\texttt{byte\_flag}为1），将缓冲区\texttt{data\_buffer}与当前读取的数据拼接为16位数据，输出到\texttt{o\_data\_bram}；
      \item 读指针\texttt{rd\_ptr\_bin}递增，并更新为Gray码\texttt{rd\_ptr\_gray}；
      \item 输出写使能信号\texttt{o\_wr\_en\_bram}，并将地址\texttt{o\_addr\_bram}递增。
    \end{itemize}
  \item 当FIFO为空时，\texttt{o\_fifo\_empty}置高，表示数据传输完成。
\end{itemize}
\paragraph{备注：}

设计思路参照文献\cite{fifo}。

\subsubsection{指令内存模块}
\paragraph{模块基本信息：}
\begin{itemize}
  \item 模块名：\texttt{BRAM\_INSTR}
  \item 最新更新日期：\texttt{4.28}
  \item 是否经过测试：否
\end{itemize}
\paragraph{模块功能：}
描述一指令内存，可存放256条2byte指令。读写双口，拥有写使能（FIFO传入）。外部设备可通过开读使能信号并传入地址读取对应地址的2byte指令。
\paragraph{模块外部接口：}
\begin{longtable}{>{\bfseries}c c c c}
  \caption{指令内存模块外部接口} \\
  \toprule
  信号名 & 方向 & 位宽 & 描述 \\
  \midrule
  \endfirsthead

  \multicolumn{4}{l}{\textbf{（续表）指令内存模块外部接口}} \\
  \toprule
  信号名 & 方向 & 位宽 & 描述 \\
  \midrule
  \endhead

  \texttt{i\_clk}          & 输入  & 1        & 系统时钟信号，驱动读写操作 \\
  \texttt{en\_write}       & 输入  & 1        & 写使能信号，高电平时允许将指令写入指令内存\\
  \texttt{en\_read}        & 输入  & 1        & 读使能信号，高电平时允许外部总线从指令内存中读取指令 \\
  \texttt{i\_addr\_write}  & 输入  & 8        & 要写入的指令地址 \\
  \texttt{i\_instr\_write} & 输入  & 16       & 要写入的指令内容 \\
  \texttt{i\_addr\_read}   & 输入  & 8        & 要读取的指令地址 \\
  \texttt{o\_instr\_read}  & 输出  & 16       & 从指令内存中读取的指令内容 \\
  \bottomrule
\end{longtable}

\paragraph{模块行为：}
\begin{itemize}
  \item 在\texttt{en\_write} 有效时，将指令内容写入指令地址；
  \item 在\texttt{en\_read} 有效时，将要读取的指令地址中的内容输出到连接外部总线的\texttt{o\_instr\_read}。
\end{itemize}


\subsection{控制单元}
控制单元由CAR、CBR寄存器和CM（Control Memory）只读模块组成。控制单元通过将存储于CM的微操作指令和控制信号输出至CBR后，再通过内部控制总线输出到各个单元（寄存器、ALU、外部总线）控制整个系统。控制单元每个时钟周期执行一条微操作指令，由表~\ref{tab:five_stage_pipeline}~可知平均每条指令需要执行8条微操作指令，故每条指令约需要8个时钟周期执行完成。

\paragraph{模块代码：}
见附录~\ref{sec:appendices:control}。

\paragraph{功能块基本信息：}
\begin{itemize}
  \item 模块名：\texttt{CU\_TOP}
  \item 最新更新日期：\texttt{2025.5.7}
  \item 是否经过测试：是
\end{itemize}

\begin{longtable}{>{\bfseries}c c c c}
  \caption{CU\_TOP模块外部接口} \\ 
  \toprule
  信号名 & 方向 & 位宽 & 描述 \\ 
  \midrule
  \endfirsthead

  \multicolumn{4}{l}{\textbf{（续表）CU\_TOP模块外部接口}} \\ 
  \toprule
  信号名 & 方向 & 位宽 & 描述 \\ 
  \midrule
  \endhead

  \texttt{i\_clk} & 输入 & 1 & 系统时钟信号 \\ 
  \texttt{i\_rst\_n} & 输入 & 1 & 全局复位信号 \\ 
  \texttt{ctrl\_cpu\_start} & 输入 & 1 & CPU启动控制信号 \\ 
  \texttt{ctrl\_step\_execution} & 输入 & 1 & 单步执行控制信号 \\ 
  \texttt{i\_next\_instr\_stimulus} & 输入 & 1 & 下一条指令触发信号 \\ 
  \texttt{i\_ir\_data} & 输入 & 8 & 当前指令操作码 \\ 
  \texttt{i\_flags} & 输入 & 5 & 状态寄存器标志位（ZF, CF, OF, NF, MF） \\ 
  \texttt{o\_alu\_op} & 输出 & 4 & ALU运算类型控制信号 \\ 
  \texttt{o\_ctrl\_mar\_increment} & 输出 & 1 & MAR自增控制信号 \\ 
  \texttt{o\_ctrl\_halt} & 输出 & 1 & 全局暂停信号 \\ 
  \texttt{C0-C15} & 输出 & $1\times 16$ & 16位寄存器控制信号 \\ 
  \bottomrule
\end{longtable}

\subsubsection{Control Memory}\label{sec:ControlMemory}
\paragraph{模块基本信息：}
\begin{itemize}
  \item 模块名：\texttt{CONTROL\_MEMORY}
  \item 最新更新日期：\texttt{5.5}
  \item 是否经过测试：是
\end{itemize}
\paragraph{模块功能：}
存储CPU的水平微操作指令，并根据输入的微操作指令地址写出控制信号到CBR。微操作指令表参考表~\ref{tab:five_stage_pipeline_ctrl}~。
\paragraph{模块外部接口：}
\begin{longtable}{>{\bfseries}c c c c}
  \caption{Control Memory模块外部接口} \\
  \toprule
  信号名 & 方向 & 位宽 & 描述 \\
  \midrule
  \endfirsthead

  \multicolumn{4}{l}{\textbf{（续表）Control Memory模块外部接口}} \\
  \toprule
  信号名 & 方向 & 位宽 & 描述 \\
  \midrule
  \endhead

  \texttt{car}   & 输入  & 7        & 要读取的微操作指令地址 \\
  \texttt{control\_word}  & 输出  & 24       & 从 CM 中读取的控制信号 \\
  \bottomrule
\end{longtable}
\paragraph{模块行为：}
输出\texttt{car}地址存储的\texttt{control\_word}。
\subsubsection{CAR}
\paragraph{模块基本信息：}
\begin{itemize}
  \item 模块名：\texttt{CAR}
  \item 最新更新日期：\texttt{5.7}
  \item 是否经过测试：是
\end{itemize}
\paragraph{模块功能：}
根据控制信号中ADDR控制字、IR Opcode 和 Flags，综合判断出下一条指令所在微操作指令的地址。
\paragraph{模块外部接口：}
\begin{longtable}{>{\bfseries}c c c c}
  \caption{CAR模块外部接口} \\
  \toprule
  信号名 & 方向 & 位宽 & 描述 \\
  \midrule
  \endfirsthead

  \multicolumn{4}{l}{\textbf{（续表）CAR模块外部接口}} \\
  \toprule
  信号名 & 方向 & 位宽 & 描述 \\
  \midrule
  \endhead
  \texttt{i\_clk}  & 输入 & 1& 时钟信号\\
  \texttt{i\_rst\_n}  & 输入 &1 & 全局复位信号 \\
  \texttt{ctrl\_cpu\_start}     & 输入 & 1 & 用户面控制，控制CPU启动与停止 \\
  \texttt{ctrl\_step\_execution} & 输入 & 1 & 用户面控制，控制CPU逐条执行指令 \\
  \texttt{i\_next\_instr\_stimulus}  & 输入 & 1 & 用户面控制，控制CPU执行下一条指令\\
  \texttt{i\_ctrl\_halt} & 输入 & 1 & HLT控制字 \\
  \texttt{i\_control\_word\_car} & 输入 & 2 & ADDR控制字（参照~\ref{sec:datapath}）\\
  \texttt{i\_ir\_data}  & 输入 & 5 & IR的最高位 + IR的低四位 \\
  \texttt{i\_ctrl\_ZF}  & 输入 & 1 & ZF值 \\
  \texttt{i\_ctrl\_NF}  & 输入 & 1 & NF值 \\
  \texttt{i\_ctrl\_MF}  & 输入 & 1 & MF值 \\
  \texttt{o\_car\_data} & 输出 & 7 & 待取指令在CM中的地址 \\
  \bottomrule
\end{longtable}
\paragraph{模块行为：}
\begin{itemize}
  \item 时钟上升沿时，若\texttt{i\_ir\_data}有效，从外部更新\texttt{ir\_data}寄存器的值；
  \item 根据\texttt{ir\_data}最高位判断是否需要IND周期，若最高位为0则置\texttt{indirect\_flag}为1，标志需要IND周期；
  \item 根据ADDR控制字决定下一条微操作指令地址：
  \begin{itemize}
    \item \textbf{跳转（01）}：\texttt{indirect\_flag}为1时，将IND周期的微指令地址写入CAR，否则进入EX阶段，根据\texttt{ir\_data}低四位、ZF、NF、MF值综合决定具体执行指令，并将微指令地址写入CAR；
    \item \textbf{自增（10）}：CAR自增；
    \item \textbf{指令结束（11）}：若HLT为1，CAR保持不变；若在单步调试功能下，CAR跳转到NOP的WB阶段，等待\texttt{i\_next\_instr\_stimulus}信号将CAR归零，否则CAR归零，自动获取下一条指令。
  \end{itemize}
\end{itemize}
\subsubsection{CBR}
\paragraph{模块基本信息：}
\begin{itemize}
  \item 模块名：\texttt{CBR}
  \item 最新更新日期：\texttt{4.28}
  \item 是否经过测试：是
\end{itemize}
\paragraph{模块功能：}
CBR寄存器用于存储控制信号，接收来自CAR的微操作指令，并将其输出到各个单元。CBR寄存器在每个时钟周期内更新一次，输出当前的控制信号。


\paragraph{模块外部接口：}
\begin{longtable}{>{\bfseries}c c c c}
  \caption{CBR模块外部接口} \\ 
  \toprule
  信号名 & 方向 & 位宽 & 描述 \\ 
  \midrule
  \endfirsthead

  \multicolumn{4}{l}{\textbf{（续表）CBR模块外部接口}} \\ 
  \toprule
  信号名 & 方向 & 位宽 & 描述 \\ 
  \midrule
  \endhead

  \texttt{memory} & 输入 & 24 & 从CM传入的控制信号 \\ 
  \texttt{ctrl\_global\_halt} & 输出 & 1 & 全局暂停信号 \\ 
  \texttt{ctrl\_mar\_increment} & 输出 & 1 & MAR自增信号 \\ 
  \texttt{next\_addr} & 输出 & 2 & 下一跳地址控制信号 \\ 
  \texttt{ALU\_op} & 输出 & 4 & ALU运算类型控制信号 \\ 
  \texttt{C0}至\texttt{C15} & 输出 & $1\times 16$ & 16位寄存器控制信号 \\ 
  \bottomrule
\end{longtable}

\paragraph{模块行为：}
\begin{itemize}
  \item 根据CM传入的24位控制信号，解析并输出以下控制信号：
    \begin{itemize}
      \item \texttt{ctrl\_global\_halt}：控制信号的第23位，即HLT；
      \item \texttt{ctrl\_mar\_increment}：控制信号的第22位，即SHP。
      \item \texttt{next\_addr}：控制信号的第21-20位，即ADDR；
      \item \texttt{ALU\_op}：控制信号的第19-16位，即$\text{ALU}_{en}$和$\text{ALU}_{op}$；
      \item \texttt{C(x)}：控制信号的第15-0位。
    \end{itemize}
\end{itemize}


\subsection{ALU和内部寄存器设计}

\paragraph{模块代码：}
见附录~\ref{sec:appendices:alu}。

\paragraph{功能块基本信息：}
\begin{itemize}
  \item 模块名：\texttt{REG\_TOP}
  \item 最新更新日期：\texttt{2025.5.7}
  \item 是否经过测试：是
\end{itemize}

\paragraph{功能块外部接口：}


\begin{longtable}{>{\bfseries}c c c c}
  \caption{REG\_TOP模块外部接口} \\ 
  \toprule
  信号名 & 方向 & 位宽 & 描述 \\ 
  \midrule
  \endfirsthead

  \multicolumn{4}{l}{\textbf{（续表）REG\_TOP模块外部接口}} \\ 
  \toprule
  信号名 & 方向 & 位宽 & 描述 \\ 
  \midrule
  \endhead

  \texttt{i\_clk} & 输入 & 1 & 系统时钟信号 \\ 
  \texttt{i\_rst\_n} & 输入 & 1 & 全局复位信号 \\ 
  \texttt{ctrl\_cpu\_start} & 输入 & 1 & CPU启动控制信号 \\ 
  \texttt{i\_alu\_op} & 输入 & 4 & ALU运算类型控制信号 \\ 
  \texttt{i\_ctrl\_halt} & 输入 & 1 & 全局暂停信号 \\ 
  \texttt{i\_ctrl\_mar\_increment} & 输入 & 1 & MAR自增控制信号 \\ 
  \texttt{i\_memory\_data} & 输入 & 16 & 从数据总线传入的数据 \\ 
  \texttt{o\_memory\_addr} & 输出 & 8 & 输出到地址总线的地址 \\ 
  \texttt{o\_memory\_data} & 输出 & 16 & 输出到数据总线的数据 \\ 
  \texttt{o\_ir\_cu} & 输出 & 8 & 输出到CU的操作码 \\ 
  \texttt{o\_flags} & 输出 & 5 & 状态寄存器标志位（ZF, CF, OF, NF, MF） \\ 
  \texttt{o\_ACC\_user} & 输出 & 16 & 输出到用户接口的ACC寄存器数据 \\ 
  \texttt{o\_MR\_user} & 输出 & 16 & 输出到用户接口的MR寄存器数据 \\ 
  \texttt{o\_PC\_user} & 输出 & 8 & 输出到用户接口的PC寄存器数据 \\ 
  \texttt{o\_IR\_user} & 输出 & 8 & 输出到用户接口的IR寄存器数据 \\ 
  \bottomrule
\end{longtable}
\subsubsection{ALU}
ALU（Arithmetic Logic Unit）是算术逻辑单元，负责执行CPU中的算术和逻辑运算。

\paragraph{模块基本信息：}
\begin{itemize}
  \item 模块名：\texttt{ALU}
  \item 最新更新日期：\texttt{2025.5.7}
  \item 是否经过测试：是
\end{itemize}

\paragraph{模块功能：}
在控制信号\texttt{ctrl\_alu\_en}有效时，根据\texttt{ctrl\_alu\_op}执行指定的运算，运算结果存储在BR（低16位）和MR（高16位）寄存器中，并更新状态寄存器（Flags），包括ZF（零标志）、CF（进位标志）、OF（溢出标志）、NF（负数标志）和MF（乘法标志）。

\paragraph{模块外部接口：}
\begin{longtable}{>{\bfseries}c c c c}
  \caption{ALU模块外部接口} \\ 
  \toprule
  信号名 & 方向 & 位宽 & 描述 \\ 
  \midrule
  \endfirsthead

  \multicolumn{4}{l}{\textbf{（续表）ALU模块外部接口}} \\ 
  \toprule
  信号名 & 方向 & 位宽 & 描述 \\ 
  \midrule
  \endhead

  \texttt{i\_clk} & 输入 & 1 & 系统时钟信号 \\ 
  \texttt{i\_rst\_n} & 输入 & 1 & 全局复位信号 \\ 
  \texttt{i\_acc\_alu\_p} & 输入 & 16 & ALU的第一个操作数 \\ 
  \texttt{i\_acc\_alu\_q} & 输入 & 16 & ALU的第二个操作数 \\ 
  \texttt{ctrl\_alu\_op} & 输入 & 3 & 运算类型控制信号 \\ 
  \texttt{ctrl\_alu\_en} & 输入 & 1 & ALU使能信号 \\ 
  \texttt{o\_br} & 输出 & 16 & 运算结果的低16位 \\ 
  \texttt{o\_mr} & 输出 & 16 & 运算结果的高16位（仅乘法有效） \\ 
  \texttt{o\_flags} & 输出 & 5 & 状态寄存器（ZF, CF, OF, NF, MF） \\ 
  \texttt{i\_user\_sample} & 输入 & 1 & 用户采样信号 \\ 
  \texttt{o\_mr\_user} & 输出 & 16 & 输出到用户接口的MR寄存器数据 \\ 
  \bottomrule
\end{longtable}

\paragraph{模块行为：}
\begin{itemize}
  \item 当\texttt{i\_rst\_n}为低电平时，BR和MR寄存器复位为\texttt{16'b0}，Flags寄存器复位为\texttt{5'b0}；
  \item 当\texttt{ctrl\_alu\_en}信号有效时，根据\texttt{ctrl\_alu\_op}执行以下运算：
    \begin{itemize}
      \item \texttt{000}：加法（ADD），结果存入BR（若高16位存在，则存入MR和BR）；
      \item \texttt{001}：减法（SUB），结果存入BR（若高16位存在，则存入MR和BR）；
      \item \texttt{010}：乘法（MPY），低16位存入BR，高16位存入MR；
      \item \texttt{011}：按位与（AND），结果存入BR；
      \item \texttt{100}：按位或（OR），结果存入BR；
      \item \texttt{101}：按位非（NOT），结果存入BR；
      \item \texttt{110}：算术右移（SHIFTR），结果存入BR；
      \item \texttt{111}：算术左移（SHIFTL），结果存入BR。
    \end{itemize}
  \item 根据运算结果更新Flags寄存器：
    \begin{itemize}
      \item \texttt{ZF}：结果为0时置1；
      \item \texttt{CF}：移位操作时存储移出的位；
      \item \texttt{OF}：算术运算溢出时置1；
      \item \texttt{NF}：结果为负数时置1；
      \item \texttt{MF}：乘法运算时置1。
    \end{itemize}
  \item 当\texttt{i\_user\_sample}信号有效时，将MR寄存器的数据输出到\texttt{o\_mr\_user}。
  \item 当\texttt{C\_10}信号有效时，MR在下一个周期清零，代表高位结果已被读取；
  \item 在其他情况下，BR和MR寄存器保持当前值。
\end{itemize}

\subsubsection{MAR}
MAR（Memory Address Register）是内存地址寄存器，用于存储当前访问的内存地址。它通过地址总线与内存交互，决定内存的读写地址。

\paragraph{模块基本信息：}
\begin{itemize}
  \item 模块名：\texttt{MAR}
  \item 最新更新日期：\texttt{2025.4.29}
  \item 是否经过测试：是
\end{itemize}

\paragraph{模块功能：}
MAR模块支持以下功能：
\begin{itemize}
  \item 在控制信号\texttt{C8}打开时，从MBR寄存器读取地址；
  \item 在控制信号\texttt{C2}打开时，从PC寄存器读取地址；
  \item 在\texttt{ctrl\_mar\_increment}信号有效时，自增地址（用于支持STOREH指令的高位存储操作）。
\end{itemize}

\paragraph{模块外部接口：}
\begin{longtable}{>{\bfseries}c c c c}
  \caption{MAR模块外部接口} \\ 
  \toprule
  信号名 & 方向 & 位宽 & 描述 \\ 
  \midrule
  \endfirsthead

  \multicolumn{4}{l}{\textbf{（续表）MAR模块外部接口}} \\ 
  \toprule
  信号名 & 方向 & 位宽 & 描述 \\ 
  \midrule
  \endhead

  \texttt{i\_clk} & 输入 & 1 & 系统时钟信号 \\ 
  \texttt{i\_rst\_n} & 输入 & 1 & 全局复位信号 \\ 
  \texttt{i\_mbr\_mar} & 输入 & 8 & 从MBR传入的地址 \\ 
  \texttt{i\_pc\_mar} & 输入 & 8 & 从PC传入的地址 \\ 
  \texttt{ctrl\_mar\_increment} & 输入 & 1 & 自增控制信号 \\ 
  \texttt{C2} & 输入 & 1 & 控制信号，允许从PC读取地址 \\ 
  \texttt{C8} & 输入 & 1 & 控制信号，允许从MBR读取地址 \\ 
  \texttt{o\_mar\_address\_bus} & 输出 & 8 & 输出到地址总线的地址 \\ 
  \bottomrule
\end{longtable}

\paragraph{模块行为：}
\begin{itemize}
  \item 当\texttt{i\_rst\_n}为低电平时，MAR寄存器复位为\texttt{8'b0}；
  \item 当\texttt{ctrl\_mar\_increment}信号有效时，MAR寄存器的值自增；
  \item 当\texttt{C8}信号有效时，MAR从\texttt{i\_mbr\_mar}读取地址；
  \item 当\texttt{C2}信号有效时，MAR从\texttt{i\_pc\_mar}读取地址；
  \item 在其他情况下，MAR保持当前值。
\end{itemize}
\subsubsection{MBR}
MBR（Memory Buffer Register）是内存缓冲寄存器，用于存储从内存读取或写入的数据。它通过数据总线与内存交互，是内存与CPU之间的数据桥梁。

\paragraph{模块基本信息：}
\begin{itemize}
  \item 模块名：\texttt{MBR}
  \item 最新更新日期：\texttt{2025.4.28}
  \item 是否经过测试：是
\end{itemize}

\paragraph{模块功能：}
MBR（Memory Buffer Register）是内存缓冲寄存器，用于存储从内存读取或写入的数据。它通过数据总线与内存交互，是内存与CPU之间的数据桥梁。MBR模块支持以下功能：
\begin{itemize}
  \item 在控制信号\texttt{C1}有效时，从PC寄存器读取地址；
  \item 在控制信号\texttt{C3}有效时，将数据传输到PC寄存器；
  \item 在控制信号\texttt{C4}有效时，将数据传输到IR寄存器；
  \item 在控制信号\texttt{C5}有效时，从数据总线读取数据；
  \item 在控制信号\texttt{C6}有效时，将数据传输到ALU的ALU\_Q输入端；
  \item 在控制信号\texttt{C8}有效时，将数据传输到MAR寄存器；
  \item 在控制信号\texttt{C11}有效时，将数据传输到ACC寄存器；
  \item 在控制信号\texttt{C12}有效时，从ACC寄存器读取数据；
  \item 在控制信号\texttt{C15}有效时，从IR寄存器读取立即操作数；
\end{itemize}

\paragraph{模块外部接口：}
\begin{longtable}{>{\bfseries}c c c c}
  \caption{MBR模块外部接口} \\ 
  \toprule
  信号名 & 方向 & 位宽 & 描述 \\ 
  \midrule
  \endfirsthead

  \multicolumn{4}{l}{\textbf{（续表）MBR模块外部接口}} \\ 
  \toprule
  信号名 & 方向 & 位宽 & 描述 \\ 
  \midrule
  \endhead

  \texttt{i\_clk} & 输入 & 1 & 系统时钟信号 \\ 
  \texttt{i\_rst\_n} & 输入 & 1 & 全局复位信号 \\ 
  \texttt{i\_pc\_mbr} & 输入 & 8 & 从PC传入的地址 \\ 
  \texttt{i\_ir\_mbr} & 输入 & 8 & 从IR传入的操作数 \\ 
  \texttt{i\_data\_bus\_mbr} & 输入 & 16 & 从数据总线传入的数据 \\ 
  \texttt{i\_acc\_mbr} & 输入 & 16 & 从ACC传入的数据 \\ 
  \texttt{o\_mbr\_data\_bus} & 输出 & 16 & 输出到数据总线的数据 \\ 
  \texttt{o\_mbr\_pc} & 输出 & 8 & 输出到PC寄存器的地址 \\ 
  \texttt{o\_mbr\_ir} & 输出 & 16 & 输出到IR寄存器的数据 \\ 
  \texttt{o\_mbr\_mar} & 输出 & 8 & 输出到MAR寄存器的地址 \\ 
  \texttt{o\_mbr\_acc} & 输出 & 16 & 输出到ACC寄存器的数据 \\ 
  \texttt{o\_mbr\_alu\_q} & 输出 & 16 & 输出到ALU的ALU\_Q输入端的数据 \\ 
  \texttt{C1} & 输入 & 1 & 控制信号，允许从PC读取地址 \\ 
  \texttt{C3} & 输入 & 1 & 控制信号，允许将数据传输到PC \\ 
  \texttt{C4} & 输入 & 1 & 控制信号，允许将数据传输到IR \\ 
  \texttt{C5} & 输入 & 1 & 控制信号，允许从数据总线读取数据 \\ 
  \texttt{C6} & 输入 & 1 & 控制信号，允许将数据传输到ALU\_Q \\ 
  \texttt{C8} & 输入 & 1 & 控制信号，允许将数据传输到MAR \\ 
  \texttt{C11} & 输入 & 1 & 控制信号，允许将数据传输到ACC \\ 
  \texttt{C12} & 输入 & 1 & 控制信号，允许从ACC读取数据 \\ 
  \texttt{C15} & 输入 & 1 & 控制信号，允许从IR读取操作数 \\ 
  \bottomrule
\end{longtable}

\paragraph{模块行为：}
\begin{itemize}
  \item 当\texttt{i\_rst\_n}为低电平时，MBR寄存器复位为\texttt{16'b0}；
  \item 当\texttt{C5}信号有效时，MBR从\texttt{i\_data\_bus\_mbr}读取数据；
  \item 当\texttt{C15}信号有效时，MBR从\texttt{i\_ir\_mbr}读取操作数；
  \item 当\texttt{C1}信号有效时，MBR从\texttt{i\_pc\_mbr}读取地址；
  \item 当\texttt{C12}信号有效时，MBR从\texttt{i\_acc\_mbr}读取数据；
  \item 当\texttt{C11}信号有效时，MBR将数据输出到\texttt{o\_mbr\_acc}；
  \item 当\texttt{C6}信号有效时，MBR将数据输出到\texttt{o\_mbr\_alu\_q}；
  \item 当\texttt{C8}信号有效时，MBR将数据输出到\texttt{o\_mbr\_mar}；
  \item 当\texttt{C3}信号有效时，MBR将数据输出到\texttt{o\_mbr\_pc}；
  \item 当\texttt{C4}信号有效时，MBR将数据输出到\texttt{o\_mbr\_ir}；
  \item 在其他情况下，MBR保持当前值。
\end{itemize}
\subsubsection{PC}
PC（Program Counter）是程序计数器，用于存储当前指令的地址，并在指令执行后指向下一条指令的地址。

\paragraph{模块基本信息：}
\begin{itemize}
  \item 模块名：\texttt{PC}
  \item 最新更新日期：\texttt{2025.4.30}
  \item 是否经过测试：是
\end{itemize}

\paragraph{模块功能：}
PC模块支持以下功能：
\begin{itemize}
  \item 在控制信号\texttt{C1}打开时，将当前地址传输到MBR寄存器；
  \item 在控制信号\texttt{C2}打开时，自增地址（用于指令取址阶段）；
  \item 在控制信号\texttt{C3}打开时，从MBR寄存器读取地址；
  \item 在复位信号有效时，PC寄存器复位为\texttt{8'd1}。
\end{itemize}

\paragraph{模块外部接口：}
\begin{longtable}{>{\bfseries}c c c c}
  \caption{PC模块外部接口} \\ 
  \toprule
  信号名 & 方向 & 位宽 & 描述 \\ 
  \midrule
  \endfirsthead

  \multicolumn{4}{l}{\textbf{（续表）PC模块外部接口}} \\ 
  \toprule
  信号名 & 方向 & 位宽 & 描述 \\ 
  \midrule
  \endhead

  \texttt{i\_clk} & 输入 & 1 & 系统时钟信号 \\ 
  \texttt{i\_rst\_n} & 输入 & 1 & 全局复位信号 \\ 
  \texttt{i\_mbr\_pc} & 输入 & 8 & 从MBR传入的地址 \\ 
  \texttt{C1} & 输入 & 1 & 控制信号，允许将当前地址传输到MBR \\ 
  \texttt{C2} & 输入 & 1 & 控制信号，允许PC自增 \\ 
  \texttt{C3} & 输入 & 1 & 控制信号，允许从MBR读取地址 \\ 
  \texttt{o\_pc\_mar} & 输出 & 8 & 输出到MAR寄存器的地址 \\ 
  \texttt{o\_pc\_mbr} & 输出 & 8 & 输出到MBR寄存器的地址 \\ 
  \texttt{o\_pc\_user} & 输出 & 8 & 输出到用户接口的地址 \\ 
  \bottomrule
\end{longtable}

\paragraph{模块行为：}
\begin{itemize}
  \item 当\texttt{i\_rst\_n}为低电平时，PC寄存器复位为\texttt{8'd1}；
  \item 当\texttt{C2}信号有效时，PC寄存器的值自增；
  \item 当\texttt{C3}信号有效时，PC从\texttt{i\_mbr\_pc}读取地址；
  \item 当\texttt{C1}信号有效时，PC将当前地址输出到\texttt{o\_pc\_mbr}；
  \item 在其他情况下，PC保持当前值。
\end{itemize}
\subsubsection{IR}
IR（Instruction Register）是指令寄存器，用于存储当前正在执行的指令，并将指令的操作码和操作数分离，供控制单元和其他模块使用。

\paragraph{模块基本信息：}
\begin{itemize}
  \item 模块名：\texttt{IR}
  \item 最新更新日期：\texttt{2025.4.30}
  \item 是否经过测试：是
\end{itemize}

\paragraph{模块功能：}
IR模块支持以下功能：
\begin{itemize}
  \item 在控制信号\texttt{C4}打开时，从MBR寄存器读取指令；
  \item 在控制信号\texttt{C14}打开时，将操作码输出到控制单元（CU）；
  \item 在控制信号\texttt{C15}打开时，将操作数输出到MBR寄存器；
  \item 在用户采样信号有效时，将操作码输出到用户接口。
\end{itemize}

\paragraph{模块外部接口：}
\begin{longtable}{>{\bfseries}c c c c}
  \caption{IR模块外部接口} \\ 
  \toprule
  信号名 & 方向 & 位宽 & 描述 \\ 
  \midrule
  \endfirsthead

  \multicolumn{4}{l}{\textbf{（续表）IR模块外部接口}} \\ 
  \toprule
  信号名 & 方向 & 位宽 & 描述 \\ 
  \midrule
  \endhead

  \texttt{i\_clk} & 输入 & 1 & 系统时钟信号 \\ 
  \texttt{i\_rst\_n} & 输入 & 1 & 全局复位信号 \\ 
  \texttt{i\_mbr\_ir} & 输入 & 16 & 从MBR传入的指令 \\ 
  \texttt{C4} & 输入 & 1 & 控制信号，允许从MBR读取指令 \\ 
  \texttt{C14} & 输入 & 1 & 控制信号，允许将操作码输出到CU \\ 
  \texttt{C15} & 输入 & 1 & 控制信号，允许将操作数输出到MBR \\ 
  \texttt{i\_user\_sample} & 输入 & 1 & 用户采样信号 \\ 
  \texttt{o\_ir\_cu} & 输出 & 8 & 输出到CU的操作码 \\ 
  \texttt{o\_ir\_mbr} & 输出 & 8 & 输出到MBR的操作数 \\ 
  \texttt{o\_ir\_user} & 输出 & 8 & 输出到用户接口的操作码 \\ 
  \bottomrule
\end{longtable}

\paragraph{模块行为：}
\begin{itemize}
  \item 当\texttt{i\_rst\_n}为低电平时，IR寄存器复位为\texttt{8'b0}；
  \item 当\texttt{C4}信号有效时，从\texttt{i\_mbr\_ir}读取指令，并将高8位存储为操作码，低8位存储为操作数；
  \item 当\texttt{C14}信号有效时，将操作码输出到\texttt{o\_ir\_cu}；
  \item 当\texttt{C15}信号有效时，将操作数输出到\texttt{o\_ir\_mbr}；
  \item 当\texttt{i\_user\_sample}信号有效时，将操作码输出到\texttt{o\_ir\_user}；
  \item 在其他情况下，IR保持当前值。
\end{itemize}
\subsubsection{ACC}
ACC（Accumulator）是累加寄存器，用于存储ALU运算的结果低16位，并作为ALU的输入之一。

\paragraph{模块基本信息：}
\begin{itemize}
  \item 模块名：\texttt{ACC}
  \item 最新更新日期：\texttt{2025.4.30}
  \item 是否经过测试：是
\end{itemize}

\paragraph{模块功能：}
ACC模块支持以下功能：
\begin{itemize}
  \item 在控制信号\texttt{C9}打开时，从BR寄存器读取数据；
  \item 在控制信号\texttt{C10}打开时，从MR寄存器读取数据；
  \item 在控制信号\texttt{C11}打开时，从MBR寄存器读取数据；
  \item 在控制信号\texttt{C12}打开时，将数据传输到MBR寄存器；
  \item 在控制信号\texttt{C7}打开时，将数据传输到ALU的ALU\_P输入端；
  \item 在用户采样信号有效时，将数据输出到用户接口。
\end{itemize}

\paragraph{模块外部接口：}
\begin{longtable}{>{\bfseries}c c c c}
  \caption{ACC模块外部接口} \\ 
  \toprule
  信号名 & 方向 & 位宽 & 描述 \\ 
  \midrule
  \endfirsthead

  \multicolumn{4}{l}{\textbf{（续表）ACC模块外部接口}} \\ 
  \toprule
  信号名 & 方向 & 位宽 & 描述 \\ 
  \midrule
  \endhead

  \texttt{i\_clk} & 输入 & 1 & 系统时钟信号 \\ 
  \texttt{i\_rst\_n} & 输入 & 1 & 全局复位信号 \\ 
  \texttt{i\_br\_acc} & 输入 & 16 & 从BR传入的数据 \\ 
  \texttt{i\_mr\_acc} & 输入 & 16 & 从MR传入的数据 \\ 
  \texttt{i\_mbr\_acc} & 输入 & 16 & 从MBR传入的数据 \\ 
  \texttt{C7} & 输入 & 1 & 控制信号，允许将数据传输到ALU\_P \\ 
  \texttt{C9} & 输入 & 1 & 控制信号，允许从BR读取数据 \\ 
  \texttt{C10} & 输入 & 1 & 控制信号，允许从MR读取数据 \\ 
  \texttt{C11} & 输入 & 1 & 控制信号，允许从MBR读取数据 \\ 
  \texttt{C12} & 输入 & 1 & 控制信号，允许将数据传输到MBR \\ 
  \texttt{i\_user\_sample} & 输入 & 1 & 用户采样信号 \\ 
  \texttt{o\_acc\_alu\_p} & 输出 & 16 & 输出到ALU的ALU\_P输入端的数据 \\ 
  \texttt{o\_acc\_mbr} & 输出 & 16 & 输出到MBR的数据 \\ 
  \texttt{o\_acc\_user} & 输出 & 16 & 输出到用户接口的数据 \\ 
  \bottomrule
\end{longtable}

\paragraph{模块行为：}
\begin{itemize}
  \item 当\texttt{i\_rst\_n}为低电平时，ACC寄存器复位为\texttt{16'b0}；
  \item 当\texttt{C9}信号有效时，ACC从\texttt{i\_br\_acc}读取数据；
  \item 当\texttt{C10}信号有效时，ACC从\texttt{i\_mr\_acc}读取数据；
  \item 当\texttt{C11}信号有效时，ACC从\texttt{i\_mbr\_acc}读取数据；
  \item 当\texttt{C12}信号有效时，ACC将数据输出到\texttt{o\_acc\_mbr}；
  \item 当\texttt{C7}信号有效时，ACC将数据输出到\texttt{o\_acc\_alu\_p}；
  \item 当\texttt{i\_user\_sample}信号有效时，ACC将数据输出到\texttt{o\_acc\_user}；
  \item 在其他情况下，ACC保持当前值。
\end{itemize}
\subsection{外部总线设计}
外部总线（External Bus）是CPU与内存或外设之间的数据交互桥梁，负责管理地址传输、数据传输以及内存设备的选择。
\paragraph{模块代码：}
见附录~\ref{sec:appendices:externalbus}。

\paragraph{模块基本信息：}
\begin{itemize}
  \item 模块名：\texttt{EXTERNAL\_BUS}
  \item 最新更新日期：\texttt{2025.5.5}
  \item 是否经过测试：是
\end{itemize}

\paragraph{模块功能：}
外部总线模块支持以下功能：
\begin{itemize}
  \item 根据控制信号决定内存的读写操作；
  \item 通过地址总线传输内存地址；
  \item 通过数据总线传输数据；
  \item 根据控制信号选择访问指令内存（ROM）或数据内存（RAM）。\footnote{尽管指令内存是可写的，但由于指令内存在初次写入后，内容不会在复位前发生变化，因此在此处将其视为只读存储器。}
\end{itemize}

\paragraph{模块外部接口：}
\begin{longtable}{>{\bfseries}c c c c}
  \caption{外部总线模块外部接口} \\ 
  \toprule
  信号名 & 方向 & 位宽 & 描述 \\ 
  \midrule
  \endfirsthead

  \multicolumn{4}{l}{\textbf{（续表）外部总线模块外部接口}} \\ 
  \toprule
  信号名 & 方向 & 位宽 & 描述 \\ 
  \midrule
  \endhead

  \texttt{i\_clk} & 输入 & 1 & 系统时钟信号 \\ 
  \texttt{i\_rst\_n} & 输入 & 1 & 全局复位信号 \\ 
  \texttt{i\_mbr\_data\_bus} & 输入 & 16 & 从MBR传入的数据 \\ 
  \texttt{i\_mar\_address\_bus} & 输入 & 8 & 从MAR传入的地址 \\ 
  \texttt{i\_instr} & 输入 & 16 & 从指令内存读取的数据 \\ 
  \texttt{i\_data} & 输入 & 16 & 从数据内存读取的数据 \\ 
  \texttt{o\_data\_bus\_mbr} & 输出 & 16 & 输出到MBR的数据 \\ 
  \texttt{o\_data\_bus\_memory} & 输出 & 16 & 输出到内存的数据 \\ 
  \texttt{o\_address\_bus\_memory} & 输出 & 8 & 输出到内存的地址 \\ 
  \texttt{o\_instr\_rom\_read} & 输出 & 1 & 指令内存读使能信号 \\ 
  \texttt{o\_data\_ram\_read} & 输出 & 1 & 数据内存读使能信号 \\ 
  \texttt{o\_data\_ram\_write} & 输出 & 1 & 数据内存写使能信号 \\ 
  \texttt{C0} & 输入 & 1 & 控制信号，允许地址总线传输 \\ 
  \texttt{C2} & 输入 & 1 & 控制信号，选择指令内存 \\ 
  \texttt{C5} & 输入 & 1 & 控制信号，允许数据总线读取 \\ 
  \texttt{C13} & 输入 & 1 & 控制信号，允许数据总线写入 \\ 
  \bottomrule
\end{longtable}

\paragraph{模块行为：}
\begin{itemize}
  \item 当\texttt{i\_rst\_n}为低电平时，所有输出信号复位为0；
  \item 当\texttt{C0}信号有效时，地址总线传输\texttt{i\_mar\_address\_bus}的值；
  \item 当\texttt{C5}和\texttt{C0}信号同时有效时：
    \begin{itemize}
      \item 若\texttt{C2}信号有效，读取指令内存，\texttt{o\_instr\_rom\_read}置1，\texttt{o\_data\_bus\_mbr}输出\texttt{i\_instr}的值；
      \item 若\texttt{C2}信号无效，读取数据内存，\texttt{o\_data\_ram\_read}置1，\texttt{o\_data\_bus\_mbr}输出\texttt{i\_data}的值。
    \end{itemize}
  \item 当\texttt{C13}和\texttt{C0}信号同时有效时：
    \begin{itemize}
      \item 数据总线传输\texttt{i\_mbr\_data\_bus}的值；
      \item \texttt{o\_data\_ram\_write}置1，写入数据内存。
    \end{itemize}
  \item 在其他情况下，所有输出信号保持为0。
\end{itemize}
\subsection{数据内存设计}
数据内存（Data RAM）是用于存储CPU运行过程中产生的数据的存储单元。它通过外部总线与CPU交互，支持数据的读写操作。
\paragraph{模块代码：}
见附录~\ref{sec:appendices:ram}。

\paragraph{模块基本信息：}
\begin{itemize}
  \item 模块名：\texttt{DATA\_RAM}
  \item 最新更新日期：\texttt{2025.5.5}
  \item 是否经过测试：是
\end{itemize}

\paragraph{模块功能：}
数据内存模块支持以下功能：
\begin{itemize}
  \item 根据输入的写地址和数据，在写使能信号有效时，将数据写入指定地址；
  \item 根据输入的读地址，在读使能信号有效时，从指定地址读取数据；
  \item 支持256条16位数据的存储。
\end{itemize}

\paragraph{模块外部接口：}
\begin{longtable}{>{\bfseries}c c c c}
  \caption{数据内存模块外部接口} \\ 
  \toprule
  信号名 & 方向 & 位宽 & 描述 \\ 
  \midrule
  \endfirsthead

  \multicolumn{4}{l}{\textbf{（续表）数据内存模块外部接口}} \\ 
  \toprule
  信号名 & 方向 & 位宽 & 描述 \\ 
  \midrule
  \endhead

  \texttt{i\_clk} & 输入 & 1 & 系统时钟信号 \\ 
  \texttt{i\_rst\_n} & 输入 & 1 & 全局复位信号 \\ 
  \texttt{ctrl\_write} & 输入 & 1 & 写使能信号，高电平表示写入有效 \\ 
  \texttt{i\_addr\_write} & 输入 & 8 & 写入地址 \\ 
  \texttt{i\_data\_write} & 输入 & 16 & 写入的数据 \\ 
  \texttt{ctrl\_read} & 输入 & 1 & 读使能信号，高电平表示读取有效 \\ 
  \texttt{i\_addr\_read} & 输入 & 8 & 读取地址 \\ 
  \texttt{o\_data\_read} & 输出 & 16 & 读取的数据 \\ 
  \bottomrule
\end{longtable}

\paragraph{模块行为：}
\begin{itemize}
  \item 当\texttt{i\_rst\_n}为低电平时，数据内存保全部清空并置0；
  \item 当\texttt{ctrl\_write}信号有效时，在时钟上升沿将\texttt{i\_data\_write}写入\texttt{i\_addr\_write}指定的地址；
  \item 当\texttt{ctrl\_read}信号有效时，从\texttt{i\_addr\_read}指定的地址读取数据，并输出到\texttt{o\_data\_read}；
  \item 在其他情况下，数据内存保持当前值。
\end{itemize}

\subsection{用户面设计}
所有来自用户的输入信号（按钮、开关）在按键消抖后传递给CPU和外设控制逻辑，所有来自CPU的输出信号通过FPGA外设（LED灯、七段显示器）控制逻辑传递给用户。

\paragraph{模块代码：}
见附录~\ref{sec:appendices:user}。

\subsubsection{按键消抖模块}
按键消抖模块（KEY\_JITTER）用于对用户输入的按钮或开关信号进行消抖处理，确保输入信号的稳定性，避免因机械抖动导致的误触发。

\paragraph{模块基本信息：}
\begin{itemize}
  \item 模块名：\texttt{KEY\_JITTER}
  \item 最新更新日期：\texttt{2025.4.25}
  \item 是否经过测试：是
\end{itemize}

\paragraph{模块功能：}
KEY\_JITTER模块支持以下功能：
\begin{itemize}
  \item 对输入的按键信号进行采样和稳定性检测；
  \item 通过计数器延迟，过滤掉机械抖动产生的短暂信号变化；
  \item 输出稳定的按键信号，供其他模块使用。
\end{itemize}

\paragraph{模块外部接口：}
\begin{longtable}{>{\bfseries}c c c c}
  \caption{KEY\_JITTER模块外部接口} \\ 
  \toprule
  信号名 & 方向 & 位宽 & 描述 \\ 
  \midrule
  \endfirsthead

  \multicolumn{4}{l}{\textbf{（续表）KEY\_JITTER模块外部接口}} \\ 
  \toprule
  信号名 & 方向 & 位宽 & 描述 \\ 
  \midrule
  \endhead
  \texttt{i\_clk} & 输入 & 1 & 系统时钟信号 \\ 
  \texttt{key\_in} & 输入 & 1 & 原始按键输入信号 \\ 
  \texttt{key\_out} & 输出 & 1 & 消抖后的稳定按键信号 \\ 
  \bottomrule
\end{longtable}

\paragraph{模块行为：}
\begin{itemize}
  \item 按键输入信号\texttt{key\_in}通过两级寄存器进行采样，检测信号变化；
  \item 当检测到信号变化时，计数器\texttt{cnt\_base}清零并开始计数；
  \item 如果信号在计数器达到最大值\texttt{CNT\_MAX}之前保持稳定，则更新输出信号\texttt{key\_out}；
  \item 如果信号在计数器计满之前发生变化，则重新开始计数；
  \item 输出信号\texttt{key\_out}仅在信号稳定后更新，根据\texttt{POSEDGE}参数决定是否仅在上升沿触发。
\end{itemize}

\paragraph{模块参数：}
\begin{itemize}
  \item \texttt{CNT\_MAX}：计数器的最大值，用于设置消抖时间窗口。默认值为\texttt{20'hf\_ffff}，对应较长的消抖时间。\textbf{此参数可在最上层模块自定义}。
  \item \texttt{POSEDGE}：用于设置输出是否仅在按键上升沿触发（冲激信号）。对于开关类型的信号，POSEDGE应设置为0，以捕获持续的高电平信号；对于按钮类型的信号，POSEDGE应设置为1，以捕获按键按下的瞬时信号。
\end{itemize}

\subsubsection{七段显示器}
\paragraph{顶层模块基本信息：}
\begin{itemize}
  \item 模块名：\texttt{SEVEN\_SEGMENT\_DISPLAY}
  \item 最新更新日期：\texttt{2025.5.6}
  \item 是否经过测试：是
\end{itemize}

\paragraph{显示模块基本信息：}
\begin{itemize}
  \item 模块名：\texttt{SEVEN\_SEGMENT}
  \item 最新更新日期：\texttt{2025.5.5}
  \item 是否经过测试：是
\end{itemize}

\paragraph{模块功能：}
七段显示器使用两个模块实现，一个为显示编码模块，用于将数字转换为七段显示器的编码，并输出轮询信号\texttt{seg\_valid}用于更新七段显示器的显示（轮询周期为2.4ms）；另外一个为顶层模块，根据用户请求将待显示的数字传入显示模块。
\paragraph{模块外部接口：}
\begin{longtable}{>{\bfseries}c c c c}
  \caption{SEVEN\_SEGMENT\_DISPLAY模块外部接口} \\ 
  \toprule
  信号名 & 方向 & 位宽 & 描述 \\ 
  \midrule
  \endfirsthead

  \multicolumn{4}{l}{\textbf{（续表）SEVEN\_SEGMENT\_DISPLAY模块外部接口}} \\ 
  \toprule
  信号名 & 方向 & 位宽 & 描述 \\ 
  \midrule
  \endhead

  \texttt{i\_clk} & 输入 & 1 & 系统时钟信号 \\ 
  \texttt{i\_rst\_n} & 输入 & 1 & 全局复位信号 \\ 
  \texttt{switch\_start\_cpu} & 输入 & 1 & CPU启动控制开关 \\ 
  \texttt{button\_check\_instruction} & 输入 & 1 & 连向BTNR \\ 
  \texttt{button\_check\_flags} & 输入 & 1 & 连向BTND \\ 
  \texttt{button\_check\_result} & 输入 & 1 & 连向BTNL \\ 
  \texttt{light\_instr\_transmit\_done} & 输入 & 1 & 指令传输完成信号 \\ 
  \texttt{segment\_current\_PC} & 输入 & 8 & 当前程序计数器值 \\ 
  \texttt{segment\_current\_Opcode} & 输入 & 8 & 当前指令操作码 \\ 
  \texttt{segment\_flags} & 输入 & 5 & 标志位状态 (ZF,CF,OF,NF,MF) \\ 
  \texttt{segment\_result\_high} & 输入 & 16 & 运算结果高16位 \\
  \texttt{segment\_result\_low} & 输入 & 16 & 运算结果低16位 \\
  \texttt{segment\_max\_instr\_addr} & 输入 & 8 & 指令内存最大地址 \\ 
  \texttt{o\_seg\_valid} & 输出 & 8 & 七段显示器使能信号 \\ 
  \texttt{o\_seg\_value} & 输出 & 8 & 七段显示器编码值 \\ 
  \bottomrule
\end{longtable}
\paragraph{模块行为：}
\begin{itemize}
  \item 当\texttt{i\_rst\_n}为低电平时，所有输出信号复位为0；
  \item 当\texttt{button\_check\_instruction}信号有效时，前四个数码管显示下一条指令的地址，后四个显示当前指令操作码；
  \item 当\texttt{button\_check\_flags}信号有效时，显示标志位状态（从高到低依次为ZF、CF、OF、NF、MF）；
  \item 当\texttt{button\_check\_result}信号有效时，显示运算结果；
  \item 当指令传输完成信号有效,且CPU未启动时，更新目前的最大指令地址（传入指令数量）。
\end{itemize}
\paragraph{模块参数：}
\begin{itemize}
  \item \texttt{SCAN\_INTERVAL}：轮询信号切换的时间间隔，单位为时钟周期。默认值为\texttt{30000}，对应2.4ms的轮询周期。\textbf{此参数可在最上层模块自定义}。
\end{itemize}
\subsubsection{LED灯显示}
\paragraph{模块基本信息：}
\begin{itemize}
  \item 模块名：\texttt{LED\_DISPLAY}
  \item 最新更新日期：\texttt{2025.5.5}
  \item 是否经过测试：是
\end{itemize}
\paragraph{模块功能：}
LED灯显示模块用于显示CPU的运行模式和运行状态。它通过控制板载两个LED灯的颜色来指示不同的状态。

\paragraph{模块外部接口：}
\begin{longtable}{>{\bfseries}c c c c}
  \caption{LED\_DISPLAY模块外部接口} \\ 
  \toprule
  信号名 & 方向 & 位宽 & 描述 \\ 
  \midrule
  \endfirsthead

  \multicolumn{4}{l}{\textbf{（续表）LED\_DISPLAY模块外部接口}} \\ 
  \toprule
  信号名 & 方向 & 位宽 & 描述 \\ 
  \midrule
  \endhead

  \texttt{i\_clk} & 输入 & 1 & 系统时钟信号 \\ 
  \texttt{i\_rst\_n} & 输入 & 1 & 全局复位信号 \\ 
  \texttt{i\_instr\_transmit\_done} & 输入 & 1 & 指令传输完成信号 \\ 
  \texttt{i\_halt} & 输入 & 1 & CPU停止信号 \\ 
  \texttt{i\_step\_execution} & 输入 & 1 & 连接BTNC \\ 
  \texttt{i\_start\_cpu} & 输入 & 1 & CPU启动控制信号 \\ 
  \texttt{RGB1\_RED} & 输出 & 1 & 左侧LED红色控制信号 \\ 
  \texttt{RGB1\_BLUE} & 输出 & 1 & 左侧LED蓝色控制信号 \\ 
  \texttt{RGB2\_RED} & 输出 & 1 & 右侧LED红色控制信号 \\ 
  \texttt{RGB2\_BLUE} & 输出 & 1 & 右侧LED蓝色控制信号 \\ 
  \texttt{RGB2\_GREEN} & 输出 & 1 & 右侧LED绿色控制信号 \\ 
  \bottomrule
\end{longtable}
\paragraph{模块行为：}
\begin{itemize}
  \item 当\texttt{i\_rst\_n}为低电平时，模块复位，所有LED灯熄灭，状态机进入\texttt{STATE\_IDLE}状态；
  \item 在\texttt{STATE\_IDLE}状态下：
    \begin{itemize}
      \item 所有LED灯熄灭；
      \item 若\texttt{i\_instr\_transmit\_done}信号有效，状态机切换到\texttt{STATE\_GREEN}；
    \end{itemize}
  \item 在\texttt{STATE\_GREEN}状态下：
    \begin{itemize}
      \item 右侧LED灯亮绿色；
      \item 若\texttt{i\_start\_cpu}信号有效，状态机切换到\texttt{STATE\_BLUE}；
    \end{itemize}
  \item 在\texttt{STATE\_BLUE}状态下：
    \begin{itemize}
      \item 右侧LED灯亮蓝色；
      \item 若\texttt{i\_halt}信号有效，状态机切换到\texttt{STATE\_RED}；
    \end{itemize}
  \item 在\texttt{STATE\_RED}状态下：
    \begin{itemize}
      \item 右侧LED灯亮红色；
    \end{itemize}
  \item 左侧LED灯的颜色根据\texttt{i\_step\_execution}信号决定：
    \begin{itemize}
      \item 若\texttt{i\_step\_execution}信号有效，左侧LED灯亮红色；
      \item 否则，左侧LED灯亮蓝色；
    \end{itemize}
\end{itemize}
\subsection{时序优化}
经由时序分析工具分析，CPU的时序路径集中在ALU和CAR模块之间，尤其是NF和ZF上。如果发生时序违例，可能会导致数据错误或系统不稳定。为了解决这个问题，我们对时序路径进行了优化，确保在时钟周期内完成数据传输和处理。

\paragraph{时序路径分析：}

整个系统由CAR模块控制，对于内存操作，CAR只需向外部总线发送控制信号，然后由外部总线转发给内存即可完成读写操作。而ALU作为纯组合逻辑单元，其内部的Flags寄存器依赖于ALU的计算结果，同时ALU的输入又取决于CAR的控制信号和内部寄存器的值。因此，从CAR到Flags寄存器的组合逻辑路径比到内存模块的路径更长。此外，ZF和NF寄存器还需要判断高16位是否为零，这引入了大量额外的组合逻辑，导致时序路径更为复杂。基于以上分析，我们需要对Flags寄存器的时序路径进行专门优化。

\paragraph{时序优化方法：}
由于某条指令产生的Flags必然不会在本指令中使用，且更新Flags的指令必然使用ALU，也就必然拥有使用ALU的EX和WB阶段，因此Flags可以使用本条指令的EX和WB阶段的两个时钟沿来更新。

按照判决Flags所需要的输入信号类型，可以将Flags分为两类：
\begin{itemize}
  \item 需要\texttt{ALU\_P}和\texttt{ALU\_Q}：OF、CF；
  \item 不需要\texttt{ALU\_P}和\texttt{ALU\_Q}：ZF、NF、MF。
\end{itemize}

对于第一类Flags，ALU的输出在EX阶段更新到Flags寄存器；对于第二类Flags，ALU的输出在WB阶段更新到Flags寄存器，它们的判决不再依赖于ALU的输出，而是依赖于寄存了ALU输出的MR、BR寄存器。这样，Flags寄存器的更新时序路径就可以分为两条，减轻了时序路径的压力。
\begin{itemize}
  \item ALU的输出在EX阶段更新到Flags寄存器，时序路径为：ALU $\rightarrow$ Flags（OF、CF）
  \item ALU的输出在WB阶段更新到Flags寄存器，时序路径为：ALU $\rightarrow$ MR/BR $\rightarrow$ Flags（ZF、NF、MF）
\end{itemize}

\paragraph{时序优化结果：}
经过上述时序优化，本设计的时序余量从原来的\texttt{0.05ns}提升至\texttt{0.36ns}，时序余量提升了\texttt{600\%}。
\section{性能分析与功能验证}
\subsection{时序分析}
使用Vivado 2024.2进行FPGA时序分析，结果如图~\ref{fig:timing}~所示。
\begin{figure}[htbp]
  \centering
  \caption{FPGA时序分析}
  \includegraphics[width = 0.95\textwidth]{figure/timing_summary.png}
  \label{fig:timing}
\end{figure}

设计的时序分析结果显示，在工作频率为\texttt{100MHz}时，所有路径均能在一个时钟周期内完成，这表明设计在FPGA上运行稳定，满足了设计要求。
\subsection{资源分析}
使用Vivado 2024.2进行FPGA资源分析，结果如图~\ref{tab:resource}~所示。
\begin{figure}[htbp]
  \centering
  \caption{FPGA资源分析}
  \includegraphics[width = 0.95\textwidth]{figure/resource_list.png}
  \label{tab:resource}
\end{figure}

在FPGA资源利用方面，核心模块主要集中在\texttt{control\_unit}（265个LUT和13个寄存器）和\texttt{internal\_registers}（220个LUT和101个寄存器）中，反映出控制通路和数据通路寄存单元的硬件开销占比较高。数据内存\texttt{data\_ram}使用了64个LUT，指令内存\texttt{bram\_instr}使用了88个LUT，全部作为存储资源，这是因为内存容量小，无需动用更稀缺的BRAM资源。显示和控制模块如\texttt{segment\_display}和按键消抖模块占用资源较少，基本在30个LUT和25个寄存器左右，属于轻量级设计。此外，设计仅使用了1个DSP资源和30个IO引脚，未出现资源瓶颈，说明在保证功能完整的同时保持了良好的资源控制，具有进一步扩展和优化的潜力。

\subsection{CPU功能仿真}
使用\textbf{开源轻量化HDL仿真工具iverilog}[\href{https://github.com/steveicarus/iverilog}{Github}]和\textbf{开源轻量化HDL波形查看工具GTKWave}[\href{https://github.com/gtkwave/gtkwave}{Github}]进行CPU功能仿真。它具有以下特性，适用于简单FPGA设计的功能仿真。
\begin{itemize}
  \item 轻量化，波形查看仅依赖命令行操作，且不需要安装额外的GUI工具；
  \item  全面的信号可视化功能，允许跟踪所有CPU寄存器；
  \item 层次化的信号分组，便于导航复杂的模块；
  \item 搜索功能，可以定位特定的信号变化；
  \item 测量工具，用于精确的时序分析；
  \item 多种信号格式（二进制、十六进制、十进制）便于数据检查。
\end{itemize}
\subsubsection{简单加法器}
\label{sec:add_one_to_hundred}
\paragraph{仿真内容：}

计算$1+2+\dots +99 +100 =5050$。

\paragraph{激励设置：}

用户首先编写源程序如下：
\lstinputlisting[language=Assembly]{../designs/input_src/add_one_to_hundred.txt}

通过python脚本将其转换为UART接收模块可以识别的二进制流，具体转换过程见附录~\ref{sec:appendices:python}。采用115200波特率输入指令内存，当指令内存发出“传输完成”信号后，打开CPU的单步调试功能。每间隔0.1ms，向CPU发出一次“下一条指令”信号，直到CPU发出“停止”信号。

这个测试样例可以测试CPU的条件跳转指令功能、加减法功能和ZF功能的正确性。
\paragraph{仿真结果：}
取100轮循环中的最后两个周期，观察ALU运算结果的变化如图~\ref{fig:sim:1}~所示。在第一轮循环中，被加数为累计的和，其值为4851，加数为99。程序首先执行$99 +4851 = 4950$。接着程序将结果存入内存地址1（累计和存放于此），然后程序将加数自增1后，加载立即数101并减去此时的加数100，得到结果大于0，ZF、NF均为0，JGZ跳转到循环开始。

第二轮循环，程序累加结果为$4950+100 = 5050$，并存入内存地址1。此时，自增后的加数也为101，减法运算结果为0，ZF置1，JGZ跳转条件不满足，循环终止，程序运行到HALT后自动终止。

通过LOAD指令查看内存地址1的值，可知运算结果为5050，结果正确。

\begin{figure}[htbp]
  \centering
  \caption{简单加法器最后两次循环仿真结果}
  \includegraphics[width = 0.75\textwidth]{figure/cpu_sim_add.png}
  \label{fig:sim:1}
\end{figure}


\subsubsection{乘法与溢出验证}\label{sec:mul:overflow}
\paragraph{仿真内容：}

计算$255\times254\times255$。

在16位有符号数乘法中，由于$32768 < 255\times254 < 65536$，会导致符号位溢出，但不会使用高16位，计算结果应为$255 \times 254 -2 ^{16}= -766$。第二次乘255会导致使用高16位存储，计算结果应为$-766 \times 255 = -195330$，映射回32位有符号数，则为\texttt{FFFD04FE}。 


\paragraph{激励设置：}

用户首先编写源程序如下：
\lstinputlisting[language=Assembly]{../designs/input_src/mul.txt}

指令输入配置与激励设置和上测试例相同。这个测试样例可以测试CPU在乘法运算下的结果存储与置标志位行为。CPU需要合理判断引入高16位前后OF标志位的判决规则改变，以及在存在高16位时调用STOREH指令存储高位。

\paragraph{仿真结果：}
\begin{figure}[htbp]
  \centering
  \caption{乘法与溢出测试例仿真结果}
  \includegraphics[width = 0.75\textwidth]{figure/cpu_sim_mul.png}
  \label{fig:sim:2}
\end{figure}

如图~\ref{fig:sim:2}~所示，乘法运算的低位、高位结果正确地存储在内存地址3和4，表明STOREH成功触发并正确执行。使用LOAD指令查看内存地址3、4的值，可知：
\begin{itemize}
  \item 第一次乘法运算结果高16位为\texttt{0}，低16位为\texttt{FD02}，OF、NF置1，表明乘法溢出且结果为负；
  \item 第二次乘法运算结果高16位为\texttt{FFFD}，低16位为\texttt{04FE}。由于乘数符号不同，乘法结果为负数，NF置1；未发生32位溢出，故OF为0。
\end{itemize}

\subsubsection{乘加运算验证}
\paragraph{仿真内容：}
计算$255\times254\times255 - 1400$的值。

由第\ref{sec:mul:overflow}节可知，$255\times254\times255 = -195330$，因此计算结果应为$-195330 - 1400 = -196730$，转换为16进制补码可得结果为\texttt{FFFCFF86}。

\paragraph{激励设置：}
用户首先编写源程序如下：
\lstinputlisting[language=Assembly]{../designs/input_src/mul_add.txt}

指令输入配置与激励设置和上测试例相同。这个测试样例可以测试CPU对32位$m\times x +n$型运算的支持。

\begin{figure}[htbp]
  \centering
  \caption{乘加运算验证仿真结果}
  \includegraphics[width = 0.75\textwidth]{figure/cpu_sim_muladd.png}
  \label{fig:sim:2-1}
\end{figure}

\paragraph{仿真结果：}
如图~\ref{fig:sim:2-1}~所示，MR被正确借位，表明减法32位运算成功被触发；运算结果的低位、高位结果正确地存储在内存地址5和6，表明STOREH成功触发并正确执行。使用LOAD指令查看内存地址5、6的值，可知：
\begin{itemize}
  \item 第一次乘法运算结果高16位为\texttt{FFFD}，低16位为\texttt{04FE}，MF、NF置1，表明乘法使用高16位且结果为负；
  \item 第二次乘法运算结果高16位为\texttt{FFFC}，低16位为\texttt{FF86}。由于MR最高位为1，NF、MF置1；未发生32位溢出，故OF为0；
  \item 存入内存后，MR归零，MF随之归零。
\end{itemize}



\subsubsection{移位运算验证}
\paragraph{仿真内容：}
\begin{itemize}
  \item \textbf{算术左右移测试：}$1 <<< 15 = 32768$，$32768 >> 10 = 32$，存入内存地址1；
  \item \textbf{移出标志位测试：}$32 << 11 = 65536$（溢出），存入内存地址2；
\end{itemize}

\begin{figure}[htbp]
  \centering
  \caption{移位运算验证仿真结果}
  \includegraphics[width = 0.75\textwidth]{figure/cpu_sim_shift.png}
  \label{fig:sim:3}
\end{figure}

\paragraph{激励设置：}

用户首先编写源程序如下：
\lstinputlisting[language=Assembly]{../designs/input_src/shift.txt}

指令输入配置与激励设置和上测试例相同。这个测试样例可以测试CPU的算术左移（SHIFTL）和算术右移（SHIFTR）指令的正确性。

\paragraph{仿真结果：}

如图~\ref{fig:sim:3}~所示，移位运算的结果正确地存储在内存地址1和2，表明移位指令执行正确。使用LOAD指令查看内存地址1、2的值，可知：
\begin{itemize}
  \item 算术左移15位后，结果为\texttt{8000}（-32768），NF置1，表明最高位正确移入符号位；
  \item 算术右移10位后，结果为\texttt{FFE0}（-32），表明符号位成功填充到移入的空位；
  \item 再算术左移11位后，结果为\texttt{0000}（65536，最高位移出），CF置1，表明移出标志位正确赋值。
\end{itemize}



\subsubsection{逻辑运算与无条件跳转验证}
\paragraph{仿真内容：}
依次完成以下操作：
\begin{itemize}
  \item $99 - 100 = -1 \text{(0xFFFF)}$；
  \item $\text{0xFFFF} \,\&\, \text{0x000C} = \text{0x000C}$；
  \item $\text{0x000C} \,\mid\, \text{0x0003} = \text{0x000F}$；
  \item $\neg\, \text{0x000F} = \text{0xFFF0}$；
  \item 跳过第10条指令，直接跳转到HALT指令，停止执行。
\end{itemize}



\paragraph{激励设置：}

用户首先编写源程序如下：
\lstinputlisting[language=Assembly]{../designs/input_src/logic.txt}

指令输入配置与激励设置和上测试例相同。这个测试样例可以测试CPU的逻辑运算指令（AND、OR、NOT）和无条件跳转指令的正确性。

\paragraph{仿真结果：}
如图~\ref{fig:sim:4}~所示，正确的逻辑运算的结果依次显示在用户面接口中，且ADD指令并未执行，可知无条件跳转指令和逻辑指令运行正确。

\begin{figure}[htbp]
  \centering
  \caption{逻辑运算与无条件跳转验证仿真结果}
  \includegraphics[width = 0.75\textwidth]{figure/cpu_sim_logic.png}
  \label{fig:sim:4}
\end{figure}

\subsection{FPGA实物验证}
\subsubsection{开发环境与测试准备}
基于Nexys 4 DDR开发板进行FPGA实物验证。该开发板使用FT2232C芯片接收来自UART引脚的串口数据，并通过同一引脚进行比特流烧录。由于本设计的CPU是基于UART接收模块接收指令，因此在测试时仅需要使用一根USB-UART转接线连接开发板和PC即可同时完成烧录和指令输入。

以下是实物测试所用的开发工具和开发环境。
\begin{itemize}
  \item 开发工具：\texttt{Vivado 2024.2}、\texttt{Python 3.12.3}、\texttt{PySerial 3.5}
  \item 测试环境：\texttt{Ubuntu 24.04}
\end{itemize}


开始测试前，首先将SD/USB跳线帽调整至USB，用于接收串口数据，然后将烧录跳线帽调整至JTAG，用于烧录比特流。完成配置后从Vivado烧录比特流，烧录完成后可看到左侧LED亮蓝灯、右侧LED亮绿色，七段数码管显示全零。这是系统的默认配置，LED灯分别代表：自动执行指令、允许接收指令。
\subsubsection{简单加法器实物验证}
首先如图(a)输入待执行汇编代码，指令通过串口输入到FPGA中，用户端显示输出的指令机器码和Testbench模板（便于仿真测试）。在这一轮测试中，CPU采用\textbf{自动模式}执行指令，左侧LED亮起蓝灯，如图~\ref{fig:FPGA_add}~所示。左上图显示：加载指令完成后指令内存的最大地址为15，即共存入15条指令。将最右侧开关打开后，CPU开始自动执行指令直到停止。CPU停止运行后，右侧LED亮起红灯，按下左侧按钮，七段数码管显示CPU运算结果值为\texttt{0x13BA}（5050），表明CPU成功执行了加法器测试程序。再按下下侧按钮，七段数码管显示ZF为1，代表最后一轮减法的值为0，ZF置1，JGZ跳转条件不满足，CPU停止执行。最后按下右侧按钮，从左至右第三、四个数码管显示下一条指令的PC值和当前指令的Opcode，分别为\texttt{0x10}和\texttt{0x07}，表明CPU成功停止在指令地址为\textbf{15}的\textbf{HALT}指令。
\begin{figure}[htbp]
  \centering
  \caption{简单加法器验证}
  \subfloat[用户端输出]{\includegraphics[width = 0.45\textwidth]{figure/serial_input.png}}
  \hspace{0.05\textwidth}
  \subfloat[FPGA验证结果]{\includegraphics[width = 0.45\textwidth]{figure/add_verification.pdf}}
  \label{fig:FPGA_add}
\end{figure}

\subsubsection{乘法与溢出实物验证}

在这一轮测试中，CPU采用\textbf{单步调试模式}执行指令，左侧LED亮起红灯。此轮仿真共计9条指令，全流程如图~\ref{fig:FPGA_mul}~所示。加载指令完成后指令内存的最大地址为9，即共存入9条指令。将最右侧开关打开后，CPU开始单步调试执行指令。

执行完第一条乘法指令后，按下左侧按钮显示结果为\texttt{0xFD02}，按下下侧按钮可见NF和OF均为1，表明乘法结果为负且发生溢出。按下中间按钮执行第二次乘法后，查看结果显示为\texttt{0xFFFD04FE}，标志位显示MF和NF均为1，这与仿真结果一致。继续按下中间按钮存储乘法结果，观察到MF标志位清零，证明乘法高位已被存入内存且MR寄存器已重置。执行LOAD 3指令后，七段数码管成功显示乘法结果低位\texttt{0x04FE}；执行LOAD 4指令后，显示高位\texttt{0xFFFD}，验证了CPU正确运算存储32位乘法结果、处理溢出的能力。
\begin{figure}[htbp]
  \centering
  \caption{乘法与溢出验证}
  \includegraphics[width = 0.75\textwidth]{figure/mul_verification.pdf}
  \label{fig:FPGA_mul}
\end{figure}

\subsubsection{乘加运算实物验证}
在这一轮测试中，CPU采用\textbf{单步调试模式}执行指令，左侧LED亮起红灯。此轮仿真共计13条指令，全流程如图~\ref{fig:FPGA_muladd}~所示。加载指令完成后指令内存的最大地址为\texttt{0x0D}，即共存入13条指令。将最右侧开关打开后，CPU开始单步调试执行指令。

\begin{figure}[htbp]
  \centering
  \caption{乘加运算验证}
  \includegraphics[width = 0.75\textwidth]{figure/mul_add_verification.pdf}
  \label{fig:FPGA_muladd}
\end{figure}

与乘法测试不同，本测试首先计算出减数$200\times7$的结果为\texttt{0x0578}（1400），再进行乘法测试得到被减数\texttt{0xFFFD04FE}，最后执行减法。从图中可以看到，减法结果与仿真结果一致并正确，显示为\texttt{0xFFFCFF86}，执行LOAD 5指令后，七段数码管成功显示乘法结果低位\texttt{0xFF86}；执行LOAD 6指令后，显示高位\texttt{0xFFFC}，验证了CPU正确运算存储32位乘加运算结果、处理溢出的能力。
\subsubsection{移位运算实物验证}

在这一轮测试中，CPU采用\textbf{单步调试模式}执行指令，左侧LED亮起红灯，全流程如图~\ref{fig:FPGA_shift}~所示。第一条指令执行完成后，查看运算结果可知为1。先对其左移15位，依次按下中间、左侧按钮查看结果，显示为\texttt{0x8000}，NF置1，表明最高位正确移入符号位。接着按下中间按钮执行右移10位，查看运算结果可知为\texttt{0xFFE0}，NF置1，表明符号位成功填充到移入的空位。最后按下中间按钮执行左移11位，查看运算结果可知为\texttt{0x0000}（65536），CF、ZF置1，表明移出标志位正确赋值。
\begin{figure}[htbp]
  \centering
  \caption{移位运算验证}
  \includegraphics[width = 0.75\textwidth]{figure/shift_verification.pdf}
  \label{fig:FPGA_shift}
\end{figure}

\subsubsection{逻辑运算与无条件跳转实物验证}

在这一轮测试中，CPU采用\textbf{单步调试模式}执行指令，左侧LED亮起红灯，全流程如图~\ref{fig:FPGA_logic}~所示。第一条指令执行完成后，查看运算结果可知为\texttt{0xFFFF}，按下左侧按钮查看ZF和NF均为1，表明减法结果为负且发生溢出。接着按下中间按钮执行逻辑与、或、非操作，依次查看运算结果可知为\texttt{0x000C}、\texttt{0x000F}、\texttt{0xFFF0}，NF置1，表明逻辑运算结果正确。最后按下中间按钮执行无条件跳转指令，CPU成功跳过ADD指令，停止在HALT指令（由于CPU停止时运算结果仍为\texttt{0xFFF0}）。
\begin{figure}[htbp]
  \centering
  \caption{逻辑运算与无条件跳转验证}
  \includegraphics[width = 0.75\textwidth]{figure/logic_verification.pdf}
  \label{fig:FPGA_logic}
\end{figure}

\section{总结与展望}
\subsection{设计总结}
本设计实现了一个基于FPGA的16位单周期CPU，支持基本的算术、逻辑、移位和跳转指令，并通过功能仿真、时序分析和FPGA实物验证，验证了设计的正确性和稳定性，满足了课程的设计要求。在设计要求之上，本设计还完成了一个简单的汇编代码编译器，并通过UART/FIFO串口通信实时写入用户编写的程序，无需在每次更改程序时重新构建、烧录，极大地提升了调试的灵活性。
\subsection{已知问题}
本设计还存在一些问题，主要问题包括：
\begin{enumerate}
  \item 仅支持32位算术运算，不支持32位逻辑运算和移位运算，但可以通过算术运算间接实现这两种运算。
  
  \item CPU没有异常处理机制，若发生异常（如未传入汇编代码或汇编代码无HALT指令时启动CPU），CPU将无法正常工作。此时需要用户复位后重新传入修改过的指令。
  
  \item 现有设计下，CPU只能单周期运行，无法实现多周期或流水线设计。由于本设计的CPU是基于单周期架构设计的，如果要实现多周期或流水线设计，需要对现有设计进行较大改动，故在本设计中不再实现。
  
  \item 现有设计在烧录后会直接点亮数码管和LED灯，长期点亮会造成潜在的功耗和发热问题。后续可在设计中加入开关或按键，允许用户选择是否点亮数码管和LED灯。
\end{enumerate}
% \nocite{FPGA-CPU}
\newpage
\printbibliography
\newpage
\addappheadtotoc
\begin{appendices}
  \section{完整设计代码}
  该部分以数据流向和从内向外的顺序，给出设计的完整代码。顶层模块放在每节的最后，展示了各个模块的连接方式。测试时使用的汇编代码由于和本设计关联不大，且在正文中有所展现，故在附录部分不再单独列出。另外，该项目代码已开源于[\href{https://github.com/LiPtP0000/CPU_Design}{Github}]，欢迎提交项目相关的issues或PR。
  \subsection{代码目录}
  \lstset{nolol=false}
  \lstlistoflistings
  \newpage
  \subsection{汇编程序处理Python脚本}\label{sec:appendices:python}
  \lstinputlisting[language=python,caption={write\_bistream.py}]{../designs/input_src/write_bitstream.py}
  \subsection{UART接收与指令内存模块}\label{sec:appendices:uart}
  该部分包含了UART接收模块、FIFO模块和指令内存模块的设计代码。
  \lstinputlisting[language=verilog,caption={uart.v}]{../designs/memory/uart.v}
  \lstinputlisting[language=verilog,caption={fifo.v}]{../designs/memory/fifo.v}
  \lstinputlisting[language=verilog,caption={bram\_instr.v}]{../designs/memory/bram_instr.v}
  \lstinputlisting[language=verilog,caption={clk\_divider.v}]{../designs/memory/clk_divider.v}
  \lstinputlisting[language=verilog,caption={top\_instr\_rom.v}]{../designs/memory/top_instr_rom.v}
  
  
  \subsection{控制单元设计}\label{sec:appendices:control}
  该部分包含了控制单元的设计模块，包括控制存储器CM、控制地址寄存器CAR、控制缓冲寄存器CBR和顶层模块。
  \lstinputlisting[language=verilog,caption={cu\_control\_memory.v}]{../designs/control_unit/cu_control_memory.v}
  \lstinputlisting[language=verilog,caption={cu\_control\_address\_register.v}]{../designs/control_unit/cu_control_address_register.v}
  \lstinputlisting[language=verilog,caption={cu\_control\_buffer\_register.v}]{../designs/control_unit/cu_control_buffer_register.v}
  \lstinputlisting[language=verilog,caption={cu\_top.v}]{../designs/control_unit/cu_top.v}
  \subsection{内部寄存器与ALU设计}\label{sec:appendices:alu}
  \lstinputlisting[language=verilog,caption={alu.v}]{../designs/registers/alu.v}
  \lstinputlisting[language=verilog,caption={acc.v}]{../designs/registers/acc.v}
  \lstinputlisting[language=verilog,caption={mar.v}]{../designs/registers/mar.v}
  \lstinputlisting[language=verilog,caption={mbr.v}]{../designs/registers/mbr.v}
  \lstinputlisting[language=verilog,caption={pc.v}]{../designs/registers/pc.v}
  \lstinputlisting[language=verilog,caption={ir.v}]{../designs/registers/ir.v}
  \lstinputlisting[language=verilog,caption={reg\_top.v}]{../designs/registers/reg_top.v}
  \subsection{数据内存设计}\label{sec:appendices:ram}
  \lstinputlisting[language=verilog,caption={top\_data\_ram.v}]{../designs/memory/top_data_ram.v}

  \subsection{外部总线设计}\label{sec:appendices:externalbus}
  \lstinputlisting[language=verilog,caption={external\_bus.v}]{../designs/memory/external_bus.v}

  \subsection{用户面设计}\label{sec:appendices:user}

  \lstinputlisting[language=verilog,caption={key\_jitter.v}]{../designs/user_interface/key_jitter.v}

  \lstinputlisting[language=verilog,caption={top\_seven\_segment.v}]{../designs/user_interface/top_seven_segment.v}

  \lstinputlisting[language=verilog,caption={seven\_segment.v}]{../designs/user_interface/seven_segment.v}

  \lstinputlisting[language=verilog,caption={led\_display.v}]{../designs/user_interface/led_display.v}

  \subsection{顶层模块、测试与验证模块}
  \lstinputlisting[language=verilog,caption={cpu\_top.v}]{../designs/top/cpu_top.v}

  \lstinputlisting[language=verilog,caption={top.v}]{../designs/top/top.v}

  \lstinputlisting[language=verilog,caption={CPU Testbench}]{../designs/sim/tb_cpu.v}

  \lstinputlisting[language=verilog,caption={含用户面Testbench}]{../designs/sim/tb_top.v}

  \lstinputlisting[language=tcl,caption={开发板引脚约束}]{../constriants/TOP.xdc}
\end{appendices}
\end{document}

%! I felt extremely sorry to remove the whole section of Pipeline Design.

% \section{流水线架构与优化策略}
% 参考资料与文献：\cite{hu2024computer}
% \subsection{流水线阶段}
% 为了加速CPU的指令执行速度，采用\textbf{6级同步流水线}完成CPU执行指令的全流程。分别为：取指令（IF），指令译码（ID），取操作数（FO），间址（IND），指令执行（EX）和写回寄存器（WB）六个阶段。流水线的六个阶段如下所示。
% $$
%   \text{IF} \rightarrow \text{ID} \rightarrow \text{FO}\rightarrow \text{IND} \rightarrow \text{EX} \rightarrow \text{WB}
% $$

% 流水线各阶段的主要工作如下：
% \begin{itemize}
%   \item \textbf{IF(Instruction Fetch):}从指令存储器中取出指令，同时确定下一条指令地址（指针指向下一条指令）；
%   \item \textbf{ID(Instruction Decode):}翻译指令，同时让计算机得出要使用的寄存器，得出寻址方式，亦或者（转移指令）是给出转移目的寄存器与转移条件；
%   \item \textbf{FO(Fetch Operands):}取立即操作数到MBR，即指令的低8位。
%   \item \textbf{IND(Indirect):}间接寻址周期，每插入一个IND周期则间接寻址深度+1。不插入IND周期则为立即数寻址。在本设计中由于不考虑间接寻址，因此最多只有1个IND周期。\textbf{立即数寻址的指令将跳过这一阶段。}
%   \item \textbf{EX(Execution):}按照微操作指令指示打开数据通路。
%   \item \textbf{WB(Write Back):}将运算结果保存到目标寄存器。
% \end{itemize}

% 因此，对于每一条指令，都会经历上述六个指令周期中的一部分，而由表~\ref{tab:five_stage_pipeline_ctrl}~可知，其中IF和ID部分所有指令公用相同的微操作指令。
% \subsection{流水线寄存器}
% 为了使多条指令各阶段的数据在转换时可以保存，避免出现输出数据被覆盖的情况，需要设立5个流水线寄存器贮存上一阶段的输出。为方便起见，这些寄存器命名统一为“阶段1\_阶段2\_SHIFT\_REG”的方式。

% 每一个寄存器所贮存的内容应当至少支撑起下一阶段的输入，基于此原则，可以给出每个转移寄存器所需贮存的内容如表~\ref{tab:pipeline:shiftreg}。
% \begin{longtable}{c c c}
%   \caption{流水线寄存器功能一览} \label{tab:pipeline:shiftreg} \\
%   \toprule
%   转移寄存器 & 贮存内容（高位到低位）  & 位宽   \\
%   \midrule
%   \endfirsthead

%   \caption[]{（续表）流水线寄存器功能一览} \\
%   \toprule
%   转移寄存器 & 贮存内容  & 位宽  \\
%   \midrule
%   \endhead

%   \midrule
%   \multicolumn{3}{r}{续下页} \\
%   \midrule
%   \endfoot

%   \bottomrule
%   \endlastfoot

%   IF\_ID\_SHIFT\_REG  & PC/MBR   & 8/16  \\
%   ID\_FO\_SHIFT\_REG  & IR    & 16  \\
%   FO\_IND\_SHIFT\_REG  & IR[15:8], MBR[7:0]    & 16  \\
%   IND\_EX\_SHIFT\_REG  & MBR/ACC   & 16/16  \\
%   EX\_WB\_SHIFT\_REG  & BR/MBR/MAR\footnote{根据指令选择存放什么寄存器中的内容，若位宽过剩，默认高位补零。}   & 32  \\
%   % WB\_OUT\_SHIFT\_REG & 指令的输出结果：ACC/MR/Flags & 36

% \end{longtable}

% \subsection{流水线冒险}
% 包含三种冒险情况：结构冒险、数据冒险、控制冒险（分支冒险）。\cite{zhihu453232311}

% 结构冒险，即\textbf{两条指令共同访问了一个外围设备，不支持同时读取/写入的情况。}在本设计中，由于采用哈佛结构，指令内存和数据RAM分开，并使用不同的数据总线和地址总线，因此不会出现结构冒险。并且，尽管不同运算指令可能会使用相同的寄存器，如MBR，但由于指令不可能同时处于相同的阶段，他们一定会被保存在不同的流水线寄存器中。

% 数据冒险，即\textbf{某指令引用了前一次的运算结果，但其结果值还未产生}。常见的数据冒险包括读后写 (Read After Write)，写后读(WAR, Write After Read) 和 写后写(WAW, Write After Write)冲突。在顺序流水线设计中，后两种数据冒险不常见，在本设计中不考虑。

% 控制冒险，即 \textbf{由于程序中存在分支、跳转等控制流改变的指令，导致流水线提前取到的指令可能是错误的}。当遇到分支指令时，流水线可能已经开始执行接下来的几条指令，而此时是否跳转还不确定，如果最终确实发生了跳转，这些指令将被作废，必须清空流水线并从正确的地址重新取指。为了解决控制冒险，本设计中采用了分支预测技术，提前猜测分支是否发生，并按照预测结果继续执行流水线，若预测正确则无需清空流水线，提高了效率；若预测失败，则需要清空错误的指令并重新取指。

% \subsection{数据冒险的解决：前递与旁路}
% 为了解决数据冒险，一般而言采用\textbf{插入空指令（NOP）}的方式。在本设计中，NOP的控制信号为全0，存放于CU的ROM第255个地址处（全1地址）。然而插入空指令降低了流水线的效率，为了提升效率，需要找到更好的解决方式。

% 为了解决RAW数据冒险，
% \subsection{控制冒险的解决：分支预测}
% 在本设计中，为了减少分支指令（JMP，JGZ）带来的流水线Flush和延迟，采用1比特分支预测进行流水线优化。

% 分支预测发生在分支指令执行至\textbf{ID}阶段时。CU在译码后发现其为跳转类指令，就会向Branch Predictor发送一个信号，要求进行分支预测。分支预测的结果决定接下来流水线中IF阶段读取指令的地址，但若在EX阶段发现预测结果和实际结果不一致，则对已抓取的所有指令清空（Flush）。分支预测的具体步骤如算法~\ref{alg:1bitBP}。

% \begin{algorithm}[htbp]
%   \caption{1-bit 分支预测}
%   \label{alg:1bitBP}
%   \begin{algorithmic}[1]
%   \State \textbf{Note:} 使用 1-bit 预测器预测分支是否跳转
%   \State \textbf{Input:} $PC, BranchTaken$
%   \State \textbf{Output:} $NextPC$
%   \State \textbf{Internal Registers:} $PredictorBit, BranchTarget$

%   \Procedure{Branch Prediction}{}
%       \If {$PredictorBit == 1$}
%           \State $PredictedTaken \gets \text{True}$
%           \State $NextPC \gets BranchTarget$
%       \Else
%           \State $PredictedTaken \gets \text{False}$
%           \State $NextPC \gets PC + 1$
%       \EndIf
%   \EndProcedure

%   \Procedure{Branch Resolution}{}
%       \If {$BranchTaken \neq PredictedTaken$}  \Comment{预测错误}
%           \State $Flush \gets 1$  \Comment{清空错误指令}
%           \State $NextPC \gets \textbf{if } BranchTaken \textbf{ then } BranchTarget \textbf{ else } PC + 1$
%       \EndIf
%       \State \textbf{Update Predictor:}
%       \State $PredictorBit \gets BranchTaken$  \Comment{更新 1-bit 预测器}
%   \EndProcedure
%   \end{algorithmic}
% \end{algorithm}

% \begin{figure}[htbp]
%   \centering
%   \caption{流水线优化:前递} \label{fig:pipeline:1}
%   \begin{tikzpicture}[x=0.8cm, y=0.8cm]



%     % % 指令标签
%     \node[anchor=east] at (0.5,-1.5) {\textbf{LOAD}~1};
%     \node[anchor=east] at (0.5,-2.5) {\textbf{ADD}~2};
%     \node[anchor=east] at (0.5,-3.5) {\textbf{ADD}~3};
%     \node[anchor=east] at (0.5,-4.5) {\textbf{STORE}~1};
%     \node[anchor=east] at (0.5,-5.5) {\textbf{SUB}~3};
%     \node[anchor=east] at (0.5,-6.5) {\textit{INSTR\_AFTER}};
    
      
%       % 指令的执行阶段（用方块）
%       \newcommand{\drawstage}[3]{ % #1: x位置，#2: y位置，#3: 字母
%         \draw[fill=blue!20] (#1,-#2) rectangle ++(1,-1);
%         \node at (#1+0.5,-#2-0.5) {\textbf{#3}};
%       }
%       \newcommand{\drawstageorange}[3]{ % #1: x位置，#2: y位置，#3: 字母
%         \draw[fill=orange!20] (#1,-#2) rectangle ++(1,-1);
%         \node at (#1+0.5,-#2-0.5) {\textbf{#3}};
%       }
%       % 手动绘制流水线阶段
%       %              x, y, 阶段
%       \drawstage{1}{1}{I}
%       \drawstage{2}{1}{D}
%       \drawstage{3}{1}{F}
%       \drawstage{4}{1}{N}
%       \drawstage{5}{1}{E}
%       \drawstage{6}{1}{W}
      
%       \drawstage{2}{2}{I}
%       \drawstage{3}{2}{D}
%       \drawstage{4}{2}{F}
%       \drawstage{5}{2}{N}
%       \drawstage{6}{2}{E}
%       \drawstage{7}{2}{W}
      
%       % % Stall 插入
%       % \draw[fill=gray!30] (3,-3) rectangle ++(1,-1);
%       % \node at (3.5,-3.5) {\textbf{Stall}};
%       \drawstage{3}{3}{I}
%       \drawstage{4}{3}{D}
%       \drawstage{5}{3}{F}
%       \drawstage{6}{3}{N}
%       \drawstage{7}{3}{E}
%       \drawstage{8}{3}{W}

%       \drawstage{4}{4}{I}
%       \drawstage{5}{4}{D}
%       \drawstage{6}{4}{F}
%       \drawstage{7}{4}{N}
%       \drawstage{8}{4}{E}
%       \drawstage{9}{4}{W}
      
%       \drawstage{5}{5}{I}
%       \drawstage{6}{5}{D}
%       \drawstage{7}{5}{F}
%       \drawstage{8}{5}{N}
%       \drawstage{9}{5}{E}
%       \drawstage{10}{5}{W}
      
%       % 注释箭头和文字
%       \draw[->, thick, blue] (5.5,-1.5) -- (5.5,-2.2);
%       \draw[->, thick, blue] (6.5,-2.5) -- (6.5,-3.2);
%       \node[anchor=west, font=\small, color = blue] at (8.6,-2) {\makecell{前递：ADD指令的ACC使用\\上一条指令运算结果，EX阶段不再读取}};
      
%       % \draw[->, thick, gray] (3.5,-2.5) -- (3.5,-3.2);
%       % \node[anchor=west, font=\small, color = gray] at (8.6,-1.75) {Stall：等待LOAD结果};
      

      
%       \end{tikzpicture}
% \end{figure}

% \begin{figure}[htbp]
%   \centering
%   \caption{流水线优化：分支预测} \label{fig:pipeline:example}
%   \begin{tikzpicture}[x=0.8cm, y=0.8cm]



%     % % 指令标签
%     \node[anchor=east] at (0.5,-1.5) {\textbf{LOAD}~1};
%     \node[anchor=east] at (0.5,-2.5) {\textbf{ADD}~2};
%     % \node[anchor=east] at (0.5,-3.5) {\textit{STALL}};
%     \node[anchor=east] at (0.5,-3.5) {\textbf{STORE}~1};
%     \node[anchor=east] at (0.5,-4.5) {\textbf{SUB}~3};
%     \node[anchor=east] at (0.5,-5.5) {\textbf{JGZ}~LOOP};
%     \node[anchor=east] at (0.5,-6.5) {\textit{INSTR\_AFTER}};
%     \node[anchor=east] at (0.5,-7.5) {\textit{(FLUSH)}};
    
      
%       % 指令的执行阶段（用方块）
%       \newcommand{\drawstage}[3]{ % #1: x位置，#2: y位置，#3: 字母
%         \draw[fill=blue!20] (#1,-#2) rectangle ++(1,-1);
%         \node at (#1+0.5,-#2-0.5) {\textbf{#3}};
%       }
%       \newcommand{\drawstageorange}[3]{ % #1: x位置，#2: y位置，#3: 字母
%         \draw[fill=orange!20] (#1,-#2) rectangle ++(1,-1);
%         \node at (#1+0.5,-#2-0.5) {\textbf{#3}};
%       }
%       % 手动绘制流水线阶段
%       %              x, y, 阶段
%       \drawstage{1}{1}{I}
%       \drawstage{2}{1}{D}
%       \drawstage{3}{1}{F}
%       \drawstage{4}{1}{N}
%       \drawstage{5}{1}{E}
%       \drawstage{6}{1}{W}
      
%       \drawstage{2}{2}{I}
%       \drawstage{3}{2}{D}
%       \drawstage{4}{2}{F}
%       \drawstage{5}{2}{N}
%       \drawstage{6}{2}{E}
%       \drawstage{7}{2}{W}
      
%       % Stall 插入
%       % \draw[fill=gray!30] (3,-3) rectangle ++(1,-1);
%       % \node at (3.5,-3.5) {\textbf{Stall}};
%       \drawstage{3}{3}{I}
%       \drawstage{4}{3}{D}
%       \drawstage{5}{3}{F}
%       \drawstage{6}{3}{N}
%       \drawstage{7}{3}{E}
%       \drawstage{8}{3}{W}

%       \drawstage{4}{4}{I}
%       \drawstage{5}{4}{D}
%       \drawstage{6}{4}{F}
%       \drawstage{7}{4}{N}
%       \drawstage{8}{4}{E}
%       \drawstage{9}{4}{W}
      
%       \drawstage{5}{5}{I}
%       \drawstageorange{6}{5}{D}
%       \drawstage{7}{5}{F}
%       \drawstage{8}{5}{N}
%       \drawstage{9}{5}{E}
%       \drawstage{10}{5}{W}

%       \drawstage{6}{6}{I}
%       \drawstage{7}{6}{D}
%       \drawstage{8}{6}{F}
%       \drawstage{7}{7}{I}
%       \drawstage{8}{7}{D}
%       \drawstage{8}{8}{I}
%       % \drawstage{6}{6}{I}
%       % \drawstageorange{7}{6}{D}
%       % \drawstage{8}{6}{F}
%       % \drawstage{9}{6}{N}
%       % \drawstage{10}{6}{E}
%       % \drawstage{11}{6}{W}
      
%       % Flush显示
%       \foreach \i in {9,10,11} {
%         \draw[fill=red!20] (\i,-6) rectangle ++(1,-1);
%         \node at (\i+0.5,-6.5) {X};
%       }
%       \foreach \i in {9,10,11,12} {
%         \draw[fill=red!20] (\i,-7) rectangle ++(1,-1);
%         \node at (\i+0.5,-7.5) {X};
%       }
%       \foreach \i in {9,10,11,12,13} {
%         \draw[fill=red!20] (\i,-8) rectangle ++(1,-1);
%         \node at (\i+0.5,-8.5) {X};
%       }
%       % 注释箭头和文字
      
%       % \draw[->, thick, orange] (9.5,-5.5) -- (9.5,-6.2);
%       % \node[anchor=west, font=\small,color = orange] at (8.6,-2.5) { 分支预测：假设跳转};
      
%       \draw[->, thick, red] (9.5,-5.5) -- (9.5,-6.2);
%       % \node[anchor=west, font=\small,color = red] at (8.6,-3.25) { Flush：跳转错误清空};
      
%       \end{tikzpicture}
% \end{figure}
% tikz 流水线图
% \begin{figure}[htbp]
%   \centering
%   \caption{流水线优化策略举例} \label{fig:pipeline:example}
%   \begin{tikzpicture}[x=0.8cm, y=0.8cm]



%     % % 指令标签
%     \node[anchor=east] at (0.5,-1.5) {\textbf{LOAD}~1};
%     \node[anchor=east] at (0.5,-2.5) {\textbf{ADD}~2};
%     \node[anchor=east] at (0.5,-3.5) {\textit{STALL}};
%     \node[anchor=east] at (0.5,-4.5) {\textbf{STORE}~1};
%     \node[anchor=east] at (0.5,-5.5) {\textbf{SUB}~3};
%     \node[anchor=east] at (0.5,-6.5) {\textbf{JGZ}~LOOP};
%     \node[anchor=east] at (0.5,-7.5) {\textit{INSTR\_AFTER}};
%     \node[anchor=east] at (0.5,-8.5) {\textit{(FLUSH)}};
    
      
%       % 指令的执行阶段（用方块）
%       \newcommand{\drawstage}[3]{ % #1: x位置，#2: y位置，#3: 字母
%         \draw[fill=blue!20] (#1,-#2) rectangle ++(1,-1);
%         \node at (#1+0.5,-#2-0.5) {\textbf{#3}};
%       }
%       \newcommand{\drawstageorange}[3]{ % #1: x位置，#2: y位置，#3: 字母
%         \draw[fill=orange!20] (#1,-#2) rectangle ++(1,-1);
%         \node at (#1+0.5,-#2-0.5) {\textbf{#3}};
%       }
%       % 手动绘制流水线阶段
%       %              x, y, 阶段
%       \drawstage{1}{1}{I}
%       \drawstage{2}{1}{D}
%       \drawstage{3}{1}{F}
%       \drawstage{4}{1}{N}
%       \drawstage{5}{1}{E}
%       \drawstage{6}{1}{W}
      
%       \drawstage{2}{2}{I}
%       \drawstage{3}{2}{D}
%       \drawstage{4}{2}{F}
%       \drawstage{5}{2}{N}
%       \drawstage{6}{2}{E}
%       \drawstage{7}{2}{W}
      
%       % Stall 插入
%       \draw[fill=gray!30] (3,-3) rectangle ++(1,-1);
%       \node at (3.5,-3.5) {\textbf{Stall}};
      
%       \drawstage{4}{4}{I}
%       \drawstage{5}{4}{D}
%       \drawstage{6}{4}{F}
%       \drawstage{7}{4}{N}
%       \drawstage{8}{4}{E}
%       \drawstage{9}{4}{W}
      
%       \drawstage{5}{5}{I}
%       \drawstage{6}{5}{D}
%       \drawstage{7}{5}{F}
%       \drawstage{8}{5}{N}
%       \drawstage{9}{5}{E}
%       \drawstage{10}{5}{W}
      
%       \drawstage{6}{6}{I}
%       \drawstageorange{7}{6}{D}
%       \drawstage{8}{6}{F}
%       \drawstage{9}{6}{N}
%       \drawstage{10}{6}{E}
%       \drawstage{11}{6}{W}
      
%       % Flush显示
%       \foreach \i in {7,8,9,10,11,12} {
%         \draw[fill=red!20] (\i,-7) rectangle ++(1,-1);
%         \node at (\i+0.5,-7.5) {X};
%       }
      
%       % 注释箭头和文字
%       \draw[->, thick, blue] (5.5,-1.5) -- (5.5,-2.2);
%       \node[anchor=west, font=\small, color = blue] at (8.6,-1) {前递：ADD使用LOAD结果};
      
%       \draw[->, thick, gray] (3.5,-2.5) -- (3.5,-3.2);
%       \node[anchor=west, font=\small, color = gray] at (8.6,-1.75) {Stall：等待LOAD结果};
      
%       % \draw[->, thick, orange] (9.5,-5.5) -- (9.5,-6.2);
%       \node[anchor=west, font=\small,color = orange] at (8.6,-2.5) { 分支预测：假设跳转};
      
%       \draw[->, thick, red] (10.5,-6.5) -- (10.5,-7.2);
%       \node[anchor=west, font=\small,color = red] at (8.6,-3.25) { Flush：跳转错误清空};
      
%       \end{tikzpicture}
% \end{figure}